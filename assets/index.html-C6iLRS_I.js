import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as l,c as p,b as r,d as n,a as t,w as a,f as c,e as s}from"./app-BJsP_neF.js";const g="/assets/AOP应用场景-记录日志-BOR3mgUv.png",d="/assets/Spring中Bean的生命周期-BqFeQDIX.png",u="/assets/Bean的生命周期简单版-B6EF5ibK.png",m="/assets/循环引用示例-CJ522tCQ.png",k="/assets/三级缓存-9XaRCa88.png",S="/assets/循环依赖的解决方案-CtN9RWeh.png",v="/assets/SpringMVC视图阶段-Dpww825r.png",h="/assets/前后端分离阶段-Dg7pJQ6H.png",b="/assets/Spring框架常见注解-C1j4Qav2.png",_="/assets/SpringBootApplication注解-DyaY3VvR.png",B="/assets/SpringBoot自动装配的流程1-DMw8wR7K.png",y="/assets/SpringBoot自动装配的流程2-DvL7nU_z.png",C="/assets/服务降级-DQuXp-T8.png",f="/assets/服务降级示例代码-BbU_icZ9.png",A="/assets/服务熔断-5fHTlrJ8.png",q="/assets/漏桶算法-DoDuwPrX.png",w="/assets/令牌桶算法-DcUpQ0SR.png",P="/assets/CAP定理-BcUhjOoM.png",R="/assets/Seata架构-DKxL3uGA.png",T="/assets/Seata的XA模式-DfKsSKjy.png",x="/assets/Seata 的 AT 模式-CmLrFBnB.png",z="/assets/Seata 的 TCC 模式-BCyteENP.png",D="/assets/接口幂等-xlI1TV5U.png",M="/assets/Token _ Redis 实现接口幂等性1-Ds4NVvNr.png",j="/assets/Token _ Redis 实现接口幂等性2-DtIRMD_W.png",V={},O=n("div",{class:"hint-container note"},[n("p",{class:"hint-container-title"},"注"),n("p",null,"此处是一些 Spring 高频面试题（持续更新中...）。")],-1),N=n("h2",{id:"目录",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#目录"},[n("span",null,"目录")])],-1),E=n("h3",{id:"spring",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#spring"},[n("span",null,"Spring")])],-1),F=c(`<h2 id="面试题汇总" tabindex="-1"><a class="header-anchor" href="#面试题汇总"><span>面试题汇总</span></a></h2><h3 id="springframework" tabindex="-1"><a class="header-anchor" href="#springframework"><span>SpringFramework</span></a></h3><div class="hint-container info"><p class="hint-container-title">Spring 框架中的 Bean 是线程安全的吗？</p><blockquote><p>不是线程安全的。</p><p>Spring 框架的 Bean 默认是单例的。</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Service</span>
<span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span><span class="token string">&quot;singleton&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre></div><p>singleton：Bean 在每个 Spring IOC 容器中只有一个实例（默认）。</p><p>prototype：一个 Bean 的定义可以有多个实例。</p><p>但 Spring Bean 并没有可变的状态（比如 Service 类和 DAO 类），所以在某种程度上说 Spring 的单例 Bean 是线程安全的。</p><p><strong>参考回答</strong>：</p><p>不是线程安全的。</p><p>Spring 框架中有一个 <code>@Scope</code> 注解，默认的值就是 singleton，单例的。</p><p>因为一般在 Spring 容器中的 Bean 都是注入的无状态对象，是没有线程安全问题的，如果在 Bean 中定义了可修改的成员变量，是要考虑线程安全问题的，可以使用多例或者加锁来解决。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">什么是 AOP ？你们项目中有没有使用到 AOP ？</p><blockquote><p><strong>AOP 称为面向切面编程</strong>：用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</p><p><strong>常见的AOP使用场景</strong>：记录操作日志、缓存处理、Spring 中内置的事务处理。</p><p>记录操作日志思路：获取请求的用户名、请求方式、访问地址、模块名称、登录 IP、操作时间，记录到数据库的日志表中。</p><p><img src="`+g+`" alt="AOP应用场景-记录日志" loading="lazy"></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">&quot;pointcut()&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">around</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//  获取用户名</span>
  <span class="token comment">// 获取请求方式</span>
  <span class="token comment">// 获取访问结果</span>
  <span class="token comment">// 获取模块名称</span>
  <span class="token comment">// 登录 IP</span>
  <span class="token comment">// 操作时间</span>
  <span class="token comment">// 保存到数据库（操作日志）    </span>
  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例代码如上：使用 AOP 中的环绕通知 + 切点表达式（找到要记录日志的方法）。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">Spring 中的事务是如何实现的？</p><blockquote><p>Spring 支持编程式事务管理和声明式事务管理两种方式：</p><ul><li>编程式事务控制：需使用 TransactionTemplate 来进行实现，对业务代码有侵入性，所以项目中很少使用。</li><li>声明式事务管理：声明式事务管理建立在 AOP 之上的。其本质是通过 AOP 功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</li></ul><p>声明式事务的核心注解：<code>@Transactional</code>。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">Spring 中事务失效的场景有哪些？</p><blockquote><p>异常捕获处理：自己通过 <code>try{} catch{}</code> 捕获了异常又不主动抛出异常。</p><p>抛出检查异常：Spring 默认只会回滚非检查异常（解决：<code>@Transactional(rollbackFor=Exception.class)</code>）。</p><p>非 <code>public</code> 方法：Spring 为方法创建代理、添加事务通知、前提条件都是该方法是 <code>public</code> 的。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">Spring 的 Bean 的生命周期。</p><blockquote><p><img src="`+d+'" alt="Spring中Bean的生命周期" loading="lazy"></p><p><strong>文字描述</strong>：</p><ol><li>通过 BeanDefinition 获取 Bean 的定义信息。</li><li>调用构造函数实例化 Bean。</li><li>Bean 的依赖注入。</li><li>处理 Aware 接口（BeanNameAware、BeanFactoryAware、ApplicationContextAware）。</li><li>Bean 的后置处理器 BeanPostProcessor-前置。</li><li>初始化方法（InitializingBean、init-method）。</li><li>Bean 的后置处理器 BeanPostProcessor-后置。</li><li>销毁 Bean。</li></ol><img src="'+u+'" alt="Bean的生命周期简单版" style="zoom:50%;"></blockquote></div><div class="hint-container info"><p class="hint-container-title">Spring 中的循环引用。</p><blockquote><p>循环引用示例：</p><p><img src="'+m+'" alt="循环引用示例" loading="lazy"></p><p><strong>Spring 是通过三级缓存解决循环依赖问题的。</strong></p><p><img src="'+k+'" alt="三级缓存" loading="lazy"></p><p><img src="'+S+`" alt="循环依赖的解决方案" loading="lazy"></p><p><strong>文字描述</strong>：</p><ul><li>循环依赖：循环依赖其实就是循环引用，也就是两个或两个以上的 Bean 互相持有对方，最终形成闭环（比如 A 依赖于 B，B 依赖于 A）。</li><li>循环依赖在 Spring 中是允许存在，Spring 框架依据三级缓存已经解决了大部分的循环依赖问题： <ol><li>一级缓存：单例池，缓存已经经历了完整的生命周期，已经初始化完成的 Bean 对象。</li><li>二级缓存：缓存早期的 Bean 对象（生命周期还没走完）。</li><li>三级缓存：缓存的是 ObjectFactory，表示对象工厂，用来创建某个对象的。</li></ol></li></ul></blockquote></div><div class="hint-container info"><p class="hint-container-title">构造方法出现了循环依赖怎么解决？</p><blockquote><p>原因：由于 Bean 的生命周期中构造函数是第一个执行的，所以 Spring 框架并不能解决构造函数的的依赖注入。</p><p>解决方案：使用 <code>@Lazy</code> 懒加载注解解决，什么时候需要对象再进行 Bean 对象的创建。</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Lazy</span> <span class="token class-name">B</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;A的构造方法执行了...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></blockquote></div><div class="hint-container info"><p class="hint-container-title">。</p><blockquote></blockquote></div><h3 id="springmvc" tabindex="-1"><a class="header-anchor" href="#springmvc"><span>SpringMVC</span></a></h3><div class="hint-container info"><p class="hint-container-title">SpringMVC 的执行流程知道嘛？</p><blockquote><p><strong>视图阶段（老旧 JSP 项目）</strong>：</p><p><img src="`+v+'" alt="SpringMVC视图阶段" loading="lazy"></p><p>文字描述（视图阶段）：</p><ol><li>用户发送出请求到前端控制器 DispatcherServlet。</li><li>DispatcherServlet 收到请求调用 HandlerMapping（处理器映射器）。</li><li>HandlerMapping 找到具体的处理器，生成处理器对象及处理器拦截器（如果有），再一起返回给 DispatcherServlet。</li><li>DispatcherServlet 调用 HandlerAdapter（处理器适配器）。</li><li>HandlerAdapter 经过适配调用具体的处理器（Handler/Controller）。</li><li>Controller 执行完成返回 ModelAndView 对象。</li><li>HandlerAdapter 将 Controller 执行结果 ModelAndView 返回给 DispatcherServlet。</li><li>DispatcherServlet 将 ModelAndView 传给 ViewReslover（视图解析器）。</li><li>ViewReslover 解析后返回具体 View（视图）。</li><li>DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。</li><li>DispatcherServlet 响应用户。</li></ol><p><strong>前后端分离阶段（接口开发）</strong>：</p><p><img src="'+h+'" alt="前后端分离阶段" loading="lazy"></p><p>文字描述（前后端分离阶段）：</p><ol><li>用户发送出请求到前端控制器 DispatcherServlet。</li><li>DispatcherServlet 收到请求调用 HandlerMapping（处理器映射器）。</li><li>HandlerMapping 找到具体的处理器，生成处理器对象及处理器拦截器（如果有），再一起返回给 DispatcherServlet。</li><li>DispatcherServlet 调用 HandlerAdapter（处理器适配器）。</li><li>HandlerAdapter 经过适配调用具体的处理器（Handler/Controller）。</li><li>方法上添加了@ResponseBody。</li><li>通过 HttpMessageConverter 来返回结果转换为 JSON 并响应。</li></ol></blockquote></div><div class="hint-container info"><p class="hint-container-title">Spring 框架常见的注解有哪些？</p><blockquote><p>Spring 的常见注解有哪些？</p><p><img src="'+b+'" alt="Spring框架常见注解" loading="lazy"></p><p>SpringMVC 常见的注解有哪些？</p><p>![SpringMVC 常见的注解](./assets/SpringMVC 常见的注解.png)</p><p>SpringBoot 常见注解有哪些？</p><p>![SpringBoot 常见注解](./assets/SpringBoot 常见注解.png)</p></blockquote></div><h3 id="springboot" tabindex="-1"><a class="header-anchor" href="#springboot"><span>SpringBoot</span></a></h3><div class="hint-container info"><p class="hint-container-title">SpringBoot 自动配置原理。</p><blockquote><p><img src="'+_+'" alt="SpringBootApplication注解" loading="lazy"></p><p><code>@SpringBootConfiguration</code>：该注解与 <code>@Configuration</code> 注解作用相同，用来声明当前也是一个配置类。</p><p><code>@ComponentScan</code>：组件扫描，默认扫描当前引导类所在包及其子包。</p><p><code>@EnableAutoConfiguration</code>：SpringBoot 实现自动化配置的核心注解。</p><p><img src="'+B+'" alt="SpringBoot自动装配的流程1" loading="lazy"></p><p><img src="'+y+'" alt="SpringBoot自动装配的流程2" loading="lazy"></p><p><strong>文字描述</strong>：</p><ol><li>在 SpringBoot 项目中的引导类上有一个注解 <code>@SpringBootApplication</code>，这个注解是对三个注解进行了封装，分别是： <ul><li><code>@SpringBootConfiguration</code>。</li><li><code>@EnableAutoConfiguration</code>。</li><li><code>@ComponentScan</code>。</li></ul></li><li>其中 <code>@EnableAutoConfiguration</code> 是实现自动化配置的核心注解： <ul><li>该注解通过 <code>@Import</code> 注解导入对应的配置选择器。</li><li>内部就是读取了该项目和该项目引用的 Jar 包的的 classpath 路径下 META-INF/spring.factories 文件中的所配置的类的全类名。</li><li>在这些配置类中所定义的 Bean 会根据条件注解所指定的条件来决定是否需要将其导入到 Spring 容器中。</li></ul></li><li>条件判断会有像 <code>@ConditionalOnClass</code> 这样的注解，判断是否有对应的 Class 文件，如果有则加载该类，把这个配置类的所有的 Bean 放入 Spring 容器中使用。</li></ol></blockquote></div><div class="hint-container info"><p class="hint-container-title">。</p><blockquote></blockquote></div><h3 id="springcloud" tabindex="-1"><a class="header-anchor" href="#springcloud"><span>SpringCloud</span></a></h3><div class="hint-container info"><p class="hint-container-title">Spring Cloud 的 5 大组件有哪些？。</p><blockquote><p>注册中心、配置中心（Nacos）。</p><p>负载均衡（Ribbon）。</p><p>远程调用（Feign）。</p><p>服务熔断（Hystrix、Sentinel）。</p><p>网关（Zuul、Gateway）。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">Nacos 和 Eureka 有哪些区别？</p><blockquote><p>Nacos 每 5s 心跳续约一次（零时实例、非临时实例、主动推送）。</p><p>Eureka 每 30s 心跳续约一次（如果 Eureka 服务 90 秒没接收到心跳则剔除服务列表）。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">你们项目负载均衡如何实现的？</p><blockquote><p>OpenFeign 整合的 Ribbon。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">Ribbon 负载均衡策略有哪些？</p><blockquote><p>RoundRobinRule：简单轮询服务列表来选择服务器。</p><p>WeightedResponseTimeRule：按照权重来选择服务器，响应时间越长，权重越小。</p><p>RandomRule：随机选择一个可用的服务器。</p><p>BestAvailableRule：忽略那些短路的服务器，并选择并发数较低的服务器。</p><p>RetryRule：重试机制的选择逻辑。</p><p>AvailabilityFilteringRule：可用性敏感策略，先过滤非健康的，再选择连接数较小的实例。</p><p>ZoneAvoidanceRule：以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">什么是服务雪崩？怎么解决这个问题？</p><blockquote><p>Hystrix、Sentinel。</p><p><strong>服务降级</strong>：</p><p><img src="'+C+'" alt="服务降级" loading="lazy"></p><p><img src="'+f+'" alt="服务降级示例代码" loading="lazy"></p><p>注意：如果降级太多，则会触发熔断机制！</p><p><strong>服务熔断</strong>：</p><p><img src="'+A+'" alt="服务熔断" loading="lazy"></p><p><strong>文字描述</strong>：</p><ul><li>服务雪崩：一个服务失败，导致整条链路的服务都失败的情形。</li><li>服务降级：服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃，<mark>一般在实际开发中与 Feign 接口整合，编写降级逻辑</mark>。</li><li>服务熔断：默认关闭，需要手动打开，如果<mark>检测到 10 秒内请求的失败率超过 50%</mark>，就触发熔断机制。<mark>之后每隔 5 秒重新尝试请求微服务</mark>，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求。</li></ul></blockquote></div><div class="hint-container info"><p class="hint-container-title">你们的微服务是怎么监控的？</p><blockquote><p>Skywalking。</p><p>Prometheus + Grafana。</p><p><strong>参考回答</strong>：</p><p>我们项目中采用的 Skywalking 进行监控的：</p><ul><li>Skywalking 主要可以监控接口、服务、物理实例的一些状态。特别是在压测的时候可以看到众多服务中哪些服务和接口比较慢，我们可以针对性的分析和优化。</li><li>我们还在 Skywalking 设置了告警规则，特别是在项目上线以后，如果报错，我们分别设置了可以给相关负责人发短信和发邮件，第一时间知道项目的 Bug 情况，第一时间修复。</li></ul></blockquote></div><div class="hint-container info"><p class="hint-container-title">你们项目中有没有做过限流？怎么做的？</p><blockquote><p>为什么要限流？</p><ol><li>并发的确大（突发流量）。</li><li>防止用户恶意刷接口。</li></ol><p>限流的实现方式：</p><ul><li><p>Tomcat（可以设置最大连接数）。</p></li><li><p>Nginx（漏桶算法）。</p></li></ul><img src="'+q+'" alt="漏桶算法" style="zoom:33%;"><ul><li>网关（令牌桶算法）。</li></ul><img src="'+w+'" alt="令牌桶算法" style="zoom:33%;"><ul><li>自定义拦截器。</li></ul><p><strong>参考回答</strong>：</p><p>先要介绍下业务，什么情况下去做限流，需要说明 QPS 具体多少。</p><ul><li>我们当时有一个活动，到了假期就会抢购优惠券，QPS 最高可以达到 2000，平时 10～50 之间，为了应对突发流量，需要做限流。</li><li>常规限流，是为了防止恶意攻击，保护系统正常运行，我们当时系统能够承受最大的 QPS 是多少（压测结果）。</li></ul></blockquote></div><div class="hint-container info"><p class="hint-container-title">解释一下 CAP 定理和 BASE 理论。</p><blockquote><p>分布式事务方案的指导。</p><p>分布式系统设计方向。</p><p>根据业务指导使用正确的技术选择。</p><p><strong>CAP 定理（分布式系统有三个指标）</strong>：</p><ul><li><mark>C</mark>onsistency（一致性）。</li><li><mark>A</mark>vailability（可用性）。</li><li><mark>P</mark>artition tolerance （分区容错性）。</li></ul><p>分布式系统无法同时满足这三个指标。</p><p>因为服务于服务之间是通过网络进行连接，所以分区容错性（P）是必然会存在的。</p><p>所以当分区出现时，系统的一致性（C）和可用性（A）就无法同时满足。</p><p>如果要保证高可用性（A）那就不能保证数据的强一致性 ==&gt; <strong>AP</strong>。</p><p>如果要保证强一致性（C）那就要放弃高可用性 ==&gt; <strong>CP</strong>。</p><img src="'+P+'" alt="CAP定理" style="zoom:33%;"><p><strong>BASE 理论（BASE 理论是对 CAP 定理的一种解决思路 - 包含三个思想）</strong>：</p><ul><li><mark>B</mark>asically <mark>A</mark>vailable （基本可用）：分布式系统在出现故障时，允许损失部分可用性，以保证核心功能可用。</li><li><mark>S</mark>oft State（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态。</li><li><mark>E</mark>ventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。</li></ul><p><strong>解决分布式事务的思想和模型</strong>：</p><ul><li>最终一致思想：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据（AP）。</li><li>强一致思想：各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚（CP）。</li></ul></blockquote></div><div class="hint-container info"><p class="hint-container-title">你们采用哪种分布式事务解决方案？</p><blockquote><p>MQ。</p><p>Seata（XA、AT、TCC）。</p><p>Seata 事务管理中有三个重要的角色：</p><ul><li>TC（Transaction Coordinator） - 事务协调者：维护全局和分支事务的状态，协调全局事务提交或回滚。</li><li>TM (Transaction Manager) - 事务管理器：定义全局事务的范围、开始全局事务、提交或回滚全局事务。</li><li>RM (Resource Manager) - 资源管理器：管理分支事务处理的资源，与 TC 交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li></ul><img src="'+R+'" alt="Seata架构" style="zoom:50%;"><p><strong>Seata 的 XA 模式</strong>：</p><img src="'+T+'" alt="Seata的XA模式" style="zoom:50%;"><p><strong>Seata 的 AT 模式</strong>：</p><img src="'+x+'" alt="Seata 的 AT 模式" style="zoom:50%;"><p><strong>Seata 的 TCC 模式</strong>：</p><img src="'+z+'" alt="Seata 的 TCC 模式" style="zoom:50%;"></blockquote></div><div class="hint-container info"><p class="hint-container-title">分布式服务的接口幂等性如何设计？</p><blockquote><p>幂等性：指的是多次调用方法或者接口，可以保证重复调用的结果和单次调用的结果一致。</p><p>需要幂等场景：</p><ul><li>用户重复点击（网络波动）。</li><li>MQ 消息重复。</li><li>应用使用失败或超时重试机制。</li></ul><p><img src="'+D+'" alt="接口幂等" loading="lazy"></p><p><strong>Token + Redis 实现接口幂等性</strong>：</p><img src="'+M+'" alt="Token + Redis 实现接口幂等性1" style="zoom:50%;"><img src="'+j+'" alt="Token + Redis 实现接口幂等性2" style="zoom:50%;"><p><strong>使用分布式锁也可以实现幂等性。</strong></p></blockquote></div><div class="hint-container info"><p class="hint-container-title">你们项目中使用了什么分布式任务调度？</p><blockquote><p>xxl-job。</p><p>xxl-job路由策略有哪些？</p><ul><li>xxl-job提供了很多的路由策略，我们平时用的较多就是：轮询、故障转移、分片广播、…。</li></ul><p>xxl-job任务执行失败怎么解决？</p><ul><li>路由策略选择故障转移，使用健康的实例来执行任务。</li><li>设置重试次数。</li><li>查看日志 + 邮件告警来通知相关负责人解决。</li></ul><p>如果有大数据量的任务同时都需要执行，怎么解决？</p><ul><li>让多个实例一块去执行（部署集群），路由策略<mark>分片广播</mark>。</li><li>在任务执行的代码中可以获取分片总数和当前分片，按照取模的方式分摊到各个实例执行。</li></ul></blockquote></div>',28);function H(I,Q){const i=o("RouteLink");return l(),p("div",null,[O,r(" more "),N,E,n("ul",null,[n("li",null,[t(i,{to:"/audition/spring/spring-framework/"},{default:a(()=>[s("SpringFramework")]),_:1})]),n("li",null,[t(i,{to:"/audition/spring/spring-mvc/"},{default:a(()=>[s("SpringMVC")]),_:1})]),n("li",null,[t(i,{to:"/audition/spring/spring-boot/"},{default:a(()=>[s("SpringBoot")]),_:1})]),n("li",null,[t(i,{to:"/audition/spring/spring-security/"},{default:a(()=>[s("SpringSecurity")]),_:1})]),n("li",null,[t(i,{to:"/audition/spring/spring-cloud/"},{default:a(()=>[s("SpringCloud")]),_:1})])]),F])}const U=e(V,[["render",H],["__file","index.html.vue"]]),X=JSON.parse('{"path":"/audition/spring/","title":"Spring","lang":"zh-CN","frontmatter":{"title":"Spring","icon":"spring","category":"面试题","tag":"面试题","timeline":true,"star":true,"description":" 注 此处是一些 Spring 高频面试题（持续更新中...）。 目录 Spring 面试题汇总 SpringFramework Spring 框架中的 Bean 是线程安全的吗？ 不是线程安全的。 Spring 框架的 Bean 默认是单例的。 singleton：Bean 在每个 Spring IOC 容器中只有一个实例（默认）。 prototyp...","head":[["meta",{"property":"og:url","content":"https://SuperChenWenjing.github.io/audition/spring/"}],["meta",{"property":"og:site_name","content":"陈文景"}],["meta",{"property":"og:title","content":"Spring"}],["meta",{"property":"og:description","content":" 注 此处是一些 Spring 高频面试题（持续更新中...）。 目录 Spring 面试题汇总 SpringFramework Spring 框架中的 Bean 是线程安全的吗？ 不是线程安全的。 Spring 框架的 Bean 默认是单例的。 singleton：Bean 在每个 Spring IOC 容器中只有一个实例（默认）。 prototyp..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-04T16:06:52.000Z"}],["meta",{"property":"article:author","content":"陈文景"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:modified_time","content":"2024-05-04T16:06:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Spring\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-04T16:06:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"陈文景\\",\\"email\\":\\"2646530197@qq.com\\",\\"url\\":\\"https://superchenwenjing.github.io\\"}]}"]],"date":"2024-03-08T16:03:07.000Z"},"headers":[{"level":2,"title":"目录","slug":"目录","link":"#目录","children":[{"level":3,"title":"Spring","slug":"spring","link":"#spring","children":[]}]},{"level":2,"title":"面试题汇总","slug":"面试题汇总","link":"#面试题汇总","children":[{"level":3,"title":"SpringFramework","slug":"springframework","link":"#springframework","children":[]},{"level":3,"title":"SpringMVC","slug":"springmvc","link":"#springmvc","children":[]},{"level":3,"title":"SpringBoot","slug":"springboot","link":"#springboot","children":[]},{"level":3,"title":"SpringCloud","slug":"springcloud","link":"#springcloud","children":[]}]}],"git":{"createdTime":1709913787000,"updatedTime":1714838812000,"contributors":[{"name":"陈文景","email":"2646530197@qq.com","commits":5}]},"readingTime":{"minutes":13.58,"words":4075},"filePathRelative":"audition/spring/README.md","localizedDate":"2024年3月8日","excerpt":"<div class=\\"hint-container note\\">\\n<p class=\\"hint-container-title\\">注</p>\\n<p>此处是一些 Spring 高频面试题（持续更新中...）。</p>\\n</div>\\n","autoDesc":true}');export{U as comp,X as data};
