import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as s,f as t}from"./app-CIEgl52B.js";const e={},l=t(`<h2 id="基础" tabindex="-1"><a class="header-anchor" href="#基础"><span>基础</span></a></h2><h3 id="关于继承" tabindex="-1"><a class="header-anchor" href="#关于继承"><span>关于继承</span></a></h3><p><strong>继承的特点：</strong></p><ul><li>子类可以继承父类的属性和行为，但是子类不能继承父类的构造器。</li><li><strong>Java是单继承模式：一个类只能继承一个直接父类。</strong></li><li>Java不支持多继承、但是支持多层继承。</li><li>Java中所有的类都是Object类的子类。</li></ul><p><strong>引发的思考：</strong></p><ul><li><p>子类是否可以继承父类的构造器？</p><p>不可以的，子类有自己的构造器，父类构造器用于初始化父类对象。</p></li><li><p>子类是否可以继承父类的私有成员？</p><p>可以的，只是不能直接访问。</p><p>子类虽然会继承父类的私有（private）的成员变量，但是子类不能直接对继承的私有成员变量进行访问，可以通过继承的 <code>get/set</code>方法进行访问。</p></li><li><p>子类是否可以继承父类的静态成员？</p><p>有争议的知识点。</p><p>子类可以直接使用父类的静态成员（共享）。</p><p>但个人认为：子类不能继承父类的静态成员（共享并非继承）。</p></li></ul><h3 id="权限修饰符" tabindex="-1"><a class="header-anchor" href="#权限修饰符"><span>权限修饰符</span></a></h3><div class="hint-container tip"><p class="hint-container-title">权限修饰符（访问控制修饰符）是什么？</p><p>用于限制类中的成员（成员变量、成员方法、构造器、代码块、...）能够被访问的范围。</p></div><p><strong>权限修饰符（访问控制修饰符）：</strong></p><table><thead><tr><th>修饰符</th><th>同一个类中</th><th>同一个包中的其它类</th><th>不同包下的子类</th><th>不同包下的无关类</th></tr></thead><tbody><tr><td><code>private</code></td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td><code>缺省</code></td><td>✅</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td><code>protected</code></td><td>✅</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td><code>public</code></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr></tbody></table><blockquote><p>控制范围：<code>private</code> &lt; <code>缺省</code> &lt; <code>protected</code> &lt; <code>public</code>。</p></blockquote><div class="hint-container warning"><p class="hint-container-title">注意</p><p>构造器的修饰符只能是权限修饰符，不能被其他任何修饰。</p><p>例如：不能被 <code>static</code>、<code>final</code>、<code>synchronized</code>、<code>abstract</code>、<code>native</code> 修饰，不能有 <code>return</code> 语句返回值。</p><p>对于 <code>static final</code> 的成员变量，习惯上使用 <code>public</code> 修饰（常量）。</p></div><h2 id="进阶" tabindex="-1"><a class="header-anchor" href="#进阶"><span>进阶</span></a></h2><h3 id="多态" tabindex="-1"><a class="header-anchor" href="#多态"><span>多态</span></a></h3><div class="hint-container tip"><p class="hint-container-title">什么是多态？</p><p>父类的引用指向子类的对象。</p><p>多态的前提条件：</p><ul><li>有<strong style="color:#fb9b5f;">继承</strong>/<strong style="color:#fb9b5f;">实现</strong>关系。</li><li>有<strong style="color:#fb9b5f;">父类引用指向子类对象</strong>。</li><li><strong style="color:#fb9b5f;">有方法重写（多态侧重行为多态）</strong>。</li></ul><p>多态格式：<code>父类类型 变量名 = new 子类类型()</code>。</p><p>多态下会产生的一个问题：</p><ul><li><strong style="color:#fb9b5f;">多态下不能使用子类的独有功能</strong>。</li><li>需要强制类型转换（从父到子）。</li><li>建议在类型转换前先通过 <code>instanceof</code> 关键字校验需要转换的类是否是由该父类产生的。</li><li>否则会出现 ClassCastException 类型转换异常的错误。</li></ul></div><p>多态中成员的访问特点？</p><ul><li>方法调用：编译看左边，运行看右边。</li><li>变量调用：编译看左边，运行也看左边。</li></ul><p>多态的前提？</p><ul><li>有继承/实现的关系。</li><li>有父类的引用指向子类对象。</li><li>有方法重写（多态注重行为多态）。</li></ul><p>多态的优点和缺点？</p><ul><li>优点：实现接触耦合，便于扩展。</li><li>缺点：多态下不能使用子类独有的功能（如果要使用子类的独有功能则需要强制类型转换）。</li></ul><h3 id="面试题" tabindex="-1"><a class="header-anchor" href="#面试题"><span>面试题</span></a></h3><p><strong>请问 <code>==</code> 和 <code>equals</code> 方法有什么区别？</strong></p><ul><li><code>==</code> 既可以比较基本数据类型也可以比较引用数据类型。 <ul><li>对于基本数据类型比较的是值。</li><li>对于引用数据类型比较的是内存地址。</li></ul></li><li><code>equals</code> 是属于 <code>java.lang.Object</code> 类中的方法。 <ul><li>如果该方法没有被重写过：则默认与 <code>==</code> 的比较逻辑一致。</li><li>如果该方法有被重写过：通常情况下，我们重写 <code>equals</code> 方法会用于比较类中相应的属性是否相等。</li></ul></li></ul><h2 id="高级" tabindex="-1"><a class="header-anchor" href="#高级"><span>高级</span></a></h2><h3 id="抽象类" tabindex="-1"><a class="header-anchor" href="#抽象类"><span>抽象类</span></a></h3><div class="hint-container tip"><p class="hint-container-title">什么是抽象类和抽象方法？</p><p>被 <code>abstract</code> 关键字修饰的类称为抽象类、被 <code>abstract</code> 关键字修饰的<strong>没有方法体的方法</strong>则称为抽象方法。</p><p>抽象类语法格式：</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token punctuation">[</span>权限修饰符<span class="token punctuation">]</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> 类名<span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token punctuation">[</span>权限修饰符<span class="token punctuation">]</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> 类名 <span class="token keyword">extends</span> 父类<span class="token punctuation">{</span> <span class="token punctuation">}</span>
</code></pre></div><p>抽象方法语法格式：</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token punctuation">[</span>权限修饰符<span class="token punctuation">]</span> <span class="token keyword">abstract</span> 返回值类型 方法名<span class="token punctuation">(</span><span class="token punctuation">[</span>形参列表<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>注意：</strong></p><ul><li><strong>抽象类不能创建对象</strong>。</li><li>抽象类是用来被继承的。</li><li>抽象类中可以没有抽象方法，但是有抽象方法的类一定是抽象类。</li><li>继承抽象类的子类需要实现抽象类中的所有抽象方法，否则自己也要成为抽象类。</li></ul><p><code>abstract</code> 关键字的注意事项：</p><ul><li>不能使用 <code>abstract</code> 关键字修饰变量、代码块、构造器。</li><li>不能使用 <code>abstract</code> 关键字修饰私有方法、静态方法、<code>final</code> 修饰的方法、<code>final</code> 修饰的类。</li></ul></div><h3 id="接口-interface" tabindex="-1"><a class="header-anchor" href="#接口-interface"><span>接口（interface）</span></a></h3><div class="hint-container tip"><p class="hint-container-title">什么是接口？</p><p>接口可以理解为一种规范，定义了一组规则，体现了现实世界中“如果你是/要...则必须...“的思想。</p><p>接口的定义格式：</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> <span class="token keyword">interface</span> 接口名<span class="token punctuation">{</span>
  <span class="token comment">// 接口的成员列表</span>
  <span class="token comment">// 公共的静态常量</span>
  <span class="token comment">// 公共的抽象方法</span>
  <span class="token comment">// 公共的默认方法（JDK1.8 以上）</span>
  <span class="token comment">// 公共的静态方法（JDK1.8 以上）</span>
  <span class="token comment">// 私有方法（JDK1.9 以上）</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>JDK8.0 之前的接口中只允许出现：</strong></p><ul><li>公共的静态常量：其中 <code>public static final</code> 可以省略。</li><li>公共的抽象方法：其中 <code>public abstract</code> 可以省略。</li></ul><p><strong>JDK8.0 的接口中允许声明默认方法和静态方法：</strong></p><ul><li><p>公共的默认方法（使用 <code>default</code> 关键字修饰 - 不能省略）：其中 <code>public</code> 可以省略（但建议保留）。</p><ul><li><p>需要用接口的实现类的对象来调用。</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">default</span> 返回值类型 方法名<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div></li></ul></li><li><p>公共的静态方法（使用 <code>static</code> 关键字修饰 - 不能省略）：其中 <code>public</code> 可以省略（但建议保留）。</p><ul><li><p>接口的静态方法必须用本身的接口名来调用。</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">static</span> 返回值类型 方法名<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div></li></ul></li></ul><p><strong>JDK9.0 的接口中允许声明私有方法：</strong></p><ul><li><p>私有方法（使用 <code>private</code> 关键字修饰 - 不能省略）。</p><ul><li><p>只能在本类中被其他的默认方法或者私有方法访问。</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> 返回值类型 方法名<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div></li></ul></li></ul><p>**补充说明：**接口中没有构造器、没有代码块，因为接口中没有成员变量需要动态初始化。</p><p><strong>注意：</strong></p><ul><li><strong>接口不能创建对象</strong>。</li><li>如果一个类既继承类又实现接口，则继承在前实现在后。</li><li>接口可以被类单实现、也可以多实现（接口可以单继承或多继承其它接口）。</li><li>一个类实现了接口，就必须重写完接口中的全部抽象方法，否则这个类需要被定义成抽象类。</li><li>一个类实现多个接口，多个接口的规范不能冲突。</li><li>一个类实现多个接口，多个接口中有同样的静态方法不冲突。</li><li>一个类继承了父类，同时又实现了接口，父类中和接口中有同名方法，默认用父类的。</li><li>一个类实现了多个接口，多个接口中存在同名的默认方法，可以不冲突，这个类重写该方法即可。</li><li>一个接口继承多个接口，是没有问题的，如果多个接口中存在规范冲突则不能多继承。</li></ul></div><h3 id="内部类" tabindex="-1"><a class="header-anchor" href="#内部类"><span>内部类</span></a></h3><div class="hint-container tip"><p class="hint-container-title">什么是内部类？</p><p>将一个类 A 定义在另一个类 B 的内部，则里面的那个类 A 就称为内部类。</p><p>内部类的分类：</p><ul><li><p>静态内部类。</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">{</span>
  <span class="token comment">// 静态内部类</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 外部类名.内部类名 对象名称 = new 外部类名.内部类构造器();</span>
<span class="token class-name">Outer<span class="token punctuation">.</span>Inner</span> inner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outer<span class="token punctuation">.</span>Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li><li><p>成员内部类。</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">{</span>
  <span class="token comment">// 成员内部类</span>
  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 外部类名.内部类名 对象名称 = new 外部类构造器().new 内部类构造器();</span>
<span class="token class-name">Outer<span class="token punctuation">.</span>Inner</span> inner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li><li><p>局部内部类。</p><p>鸡肋语法、知道即可。</p></li><li><p>匿名内部类。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 格式：</span>
<span class="token comment">// new 类名称 | 抽象类名称 | 接口名称 () {</span>
<span class="token comment">//   重写方法;</span>
<span class="token comment">// };</span>

<span class="token comment">// 范例：</span>
<span class="token class-name">Employee</span> employee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
employee<span class="token punctuation">.</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>匿名内部类的特点总结：</p><ul><li>匿名内部类是一个<strong>没有名字的内部类，同时也代表一个对象</strong>。</li><li><strong>匿名内部类产生的对象类型，相当于是当前<code>new</code>的那个的类型的子类类型</strong>。</li><li>匿名内部类可以作为一个对象，直接传输给方法。</li><li>匿名内部类通常是在开发中调用别人的方法时，别人需要我们写的时候才会定义出来使用。</li><li>匿名内部类还可以通过<code>Lambda</code>表达式实现进一步的简化代码。</li></ul></li></ul></div><h3 id="枚举类" tabindex="-1"><a class="header-anchor" href="#枚举类"><span>枚举类</span></a></h3><div class="hint-container tip"><p class="hint-container-title">什么是枚举类？</p><p>枚举是 Java 中的一种特殊类型。</p><p>枚举的作用：是为了做信息的标志和信息的分类。</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>修饰符 <span class="token keyword">enum</span> 枚举名称 <span class="token punctuation">{</span>
  枚举实例的名称（每个枚举实例都是该枚举类的实例对象）
<span class="token punctuation">}</span>
</code></pre></div><p><strong>枚举类的特征：</strong></p><ul><li>枚举类都是继承了枚举类型 <code>java.lang.Enum</code>。</li><li><strong>枚举都是最终类，不可以被继承</strong>。</li><li><strong>构造器都是私有的，枚举对外不能创建对象</strong>。</li><li>枚举类相当于是多例模式。</li></ul></div><h3 id="注解" tabindex="-1"><a class="header-anchor" href="#注解"><span>注解</span></a></h3><div class="hint-container tip"><p class="hint-container-title">什么是注解？</p><p>Annotation 可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。</p><p>元注解（注解的注解）：</p><ul><li>@Target：用于描述注解的使用范围。 <ul><li>可以通过枚举类型 ElementType 的 10 个常量对象来指定。</li></ul></li><li>@Retention：用于描述注解的生命周期。 <ul><li>可以通过枚举类型 RetentionPolicy 的 3 个常量对象来指定。</li><li>SOURCE（源代码）、CLASS（字节码）、RUNTIME（运行时）。</li><li>唯有 RUNTIME 阶段才能被反射读取到。</li></ul></li><li>@Documented：表明这个注解应该被 JavaDoc 工具记录。</li><li>@Inherited：允许子类继承父类中的注解。</li></ul><p><strong>自定义注解：</strong></p><p>一个完整的注解应该包含三个部分：声明、使用、读取。</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>@元注解
<span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> <span class="token annotation punctuation">@interface</span> 注解名 <span class="token punctuation">{</span>
  <span class="token comment">// 成员列表</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注：需配合反射技术实现（待补充完整）。</p></div>`,35),p=[l];function o(c,i){return n(),s("div",null,p)}const u=a(e,[["render",o],["__file","index.html.vue"]]),k=JSON.parse('{"path":"/notes/java/oop/","title":"面向对象","lang":"zh-CN","frontmatter":{"title":"面向对象","icon":"Code","category":"Java","timeline":true,"star":true,"description":"基础 关于继承 继承的特点： 子类可以继承父类的属性和行为，但是子类不能继承父类的构造器。 Java是单继承模式：一个类只能继承一个直接父类。 Java不支持多继承、但是支持多层继承。 Java中所有的类都是Object类的子类。 引发的思考： 子类是否可以继承父类的构造器？ 不可以的，子类有自己的构造器，父类构造器用于初始化父类对象。 子类是否可以继...","head":[["meta",{"property":"og:url","content":"https://SuperChenWenjing.github.io/notes/java/oop/"}],["meta",{"property":"og:site_name","content":"陈文景"}],["meta",{"property":"og:title","content":"面向对象"}],["meta",{"property":"og:description","content":"基础 关于继承 继承的特点： 子类可以继承父类的属性和行为，但是子类不能继承父类的构造器。 Java是单继承模式：一个类只能继承一个直接父类。 Java不支持多继承、但是支持多层继承。 Java中所有的类都是Object类的子类。 引发的思考： 子类是否可以继承父类的构造器？ 不可以的，子类有自己的构造器，父类构造器用于初始化父类对象。 子类是否可以继..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-13T16:03:22.000Z"}],["meta",{"property":"article:author","content":"陈文景"}],["meta",{"property":"article:modified_time","content":"2024-04-13T16:03:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面向对象\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-13T16:03:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"陈文景\\",\\"email\\":\\"2646530197@qq.com\\",\\"url\\":\\"https://superchenwenjing.github.io\\"}]}"]],"date":"2024-04-06T07:26:51.000Z"},"headers":[{"level":2,"title":"基础","slug":"基础","link":"#基础","children":[{"level":3,"title":"关于继承","slug":"关于继承","link":"#关于继承","children":[]},{"level":3,"title":"权限修饰符","slug":"权限修饰符","link":"#权限修饰符","children":[]}]},{"level":2,"title":"进阶","slug":"进阶","link":"#进阶","children":[{"level":3,"title":"多态","slug":"多态","link":"#多态","children":[]},{"level":3,"title":"面试题","slug":"面试题","link":"#面试题","children":[]}]},{"level":2,"title":"高级","slug":"高级","link":"#高级","children":[{"level":3,"title":"抽象类","slug":"抽象类","link":"#抽象类","children":[]},{"level":3,"title":"接口（interface）","slug":"接口-interface","link":"#接口-interface","children":[]},{"level":3,"title":"内部类","slug":"内部类","link":"#内部类","children":[]},{"level":3,"title":"枚举类","slug":"枚举类","link":"#枚举类","children":[]},{"level":3,"title":"注解","slug":"注解","link":"#注解","children":[]}]}],"git":{"createdTime":1712388411000,"updatedTime":1713024202000,"contributors":[{"name":"陈文景","email":"2646530197@qq.com","commits":3}]},"readingTime":{"minutes":8.43,"words":2529},"filePathRelative":"notes/java/oop/README.md","localizedDate":"2024年4月6日","excerpt":"","autoDesc":true}');export{u as comp,k as data};
