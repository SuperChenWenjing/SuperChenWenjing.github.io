import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,b as n,d as t,f as o}from"./app-CW2uoSMw.js";const c="/assets/Redis主从集群结构-Decivwyd.png",l="/assets/上传compose文件到Linux中-BaNyWmZu.png",p="/assets/Redis全量同步-CU5huoC6.png",d="/assets/Redis全量同步-新-DXgB_VTv.png",i="/assets/节点1运行日志-C8QS7Hlq.png",r="/assets/节点2运行日志-BJboX43V.png",u="/assets/Redis增量同步-B50gNU8f.png",m={},k=t("p",null,"此处是一些 Redis 集群的高频面试题（持续更新中...）。",-1),v=o('<h2 id="_1-集群篇" tabindex="-1"><a class="header-anchor" href="#_1-集群篇"><span>1.集群篇</span></a></h2><h3 id="_1-1-主从集群" tabindex="-1"><a class="header-anchor" href="#_1-1-主从集群"><span>1.1 主从集群</span></a></h3><div class="hint-container tip"><p class="hint-container-title">为什么需要搭建集群？</p><p>单节点 Redis 的并发能力是有上限的，要进一步提高 Redis 的并发能力，就需要搭建主从集群，实现读写分离。</p></div><h4 id="_1-1-1-主从集群结构" tabindex="-1"><a class="header-anchor" href="#_1-1-1-主从集群结构"><span>1.1.1 主从集群结构</span></a></h4><p><img src="'+c+`" alt="Redis主从集群结构" loading="lazy"></p><p><strong>如图所示：</strong></p><p>集群中有一个 master 节点、两个 slave 节点（现在叫 replica）。</p><p>当我们通过 Redis 的 Java 客户端访问主从集群时应该做好路由。</p><ul><li>如果是写操作：应该访问 master 节点，master 节点会自动将数据同步给两个 slave 节点。</li><li>如果是读操作：建议访问各个 slave 节点，从而分担并发压力。</li></ul><h3 id="_1-2-搭建主从集群" tabindex="-1"><a class="header-anchor" href="#_1-2-搭建主从集群"><span>1.2 搭建主从集群</span></a></h3><p>我们会在同一个虚拟机中利用 3 个 Docker 容器来搭建主从集群。</p><p>容器信息如下：</p><table><thead><tr><th style="text-align:left;">容器名</th><th style="text-align:left;">角色</th><th style="text-align:left;">IP</th><th style="text-align:left;">映射端口</th></tr></thead><tbody><tr><td style="text-align:left;">r1</td><td style="text-align:left;">master</td><td style="text-align:left;">192.168.150.101</td><td style="text-align:left;">7001</td></tr><tr><td style="text-align:left;">r2</td><td style="text-align:left;">slave</td><td style="text-align:left;">192.168.150.101</td><td style="text-align:left;">7002</td></tr><tr><td style="text-align:left;">r3</td><td style="text-align:left;">slave</td><td style="text-align:left;">192.168.150.101</td><td style="text-align:left;">7003</td></tr></tbody></table><h4 id="_1-2-1-启动多个-redis-实例" tabindex="-1"><a class="header-anchor" href="#_1-2-1-启动多个-redis-实例"><span>1.2.1 启动多个 Redis 实例</span></a></h4><p>我们利用 docker-compose 文件来构建主从集群。</p><p>文件内容如下：</p><div class="language-yaml line-numbers-mode" data-ext="yml" data-title="yml"><pre class="language-yaml"><code><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">&quot;3.2&quot;</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">r1</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> r1
    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span>
    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-server&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7001&quot;</span><span class="token punctuation">]</span>
  <span class="token key atrule">r2</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> r2
    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span>
    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-server&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7002&quot;</span><span class="token punctuation">]</span>
  <span class="token key atrule">r3</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> r3
    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span>
    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-server&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7003&quot;</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将其上传至虚拟机的<code>/root/redis</code>目录下：</p><p><img src="`+l+`" alt="上传compose文件到Linux中" loading="lazy"></p><p>执行命令并运行集群：</p><div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> compose up <span class="token parameter variable">-d</span>
</code></pre></div><p>查看结果。</p><h4 id="_1-2-2-建立集群关系" tabindex="-1"><a class="header-anchor" href="#_1-2-2-建立集群关系"><span>1.2.2 建立集群关系</span></a></h4><p>虽然我们启动了 3 个 Redis 实例，但是它们并没有形成主从关系。</p><p>我们需要通过命令来配置主从关系：</p><div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># Redis5.0 以前</span>
slaveof <span class="token operator">&lt;</span>masterip<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>masterport<span class="token operator">&gt;</span>
<span class="token comment"># Redis5.0 以后</span>
replicaof <span class="token operator">&lt;</span>masterip<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>masterport<span class="token operator">&gt;</span>
</code></pre></div><p>有临时和永久两种模式：</p><ul><li>永久生效：在 <code>redis.conf</code> 文件中利用 <code>slaveof</code> 命令指定 <code>master</code> 节点。</li><li>临时生效：直接利用 <code>redis-cli</code> 控制台输入 <code>slaveof</code> 命令指定 <code>master</code> 节点。</li></ul><p>我们测试临时模式：首先连接 <code>r2</code>，让其以 <code>r1</code> 为 master。</p><div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 连接 r2</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> r2 redis-cli <span class="token parameter variable">-p</span> <span class="token number">7002</span>
<span class="token comment"># 认 r1 主,也就是 7001</span>
slaveof <span class="token number">192.168</span>.150.101 <span class="token number">7001</span>
</code></pre></div><p>然后连接 <code>r3</code>，让其以 <code>r1</code> 为 master。</p><div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 连接 r3</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> r3 redis-cli <span class="token parameter variable">-p</span> <span class="token number">7003</span>
<span class="token comment"># 认 r1 主，也就是 7001</span>
slaveof <span class="token number">192.168</span>.150.101 <span class="token number">7001</span>
</code></pre></div><p>然后连接 <code>r1</code>，查看集群状态：</p><div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 连接 r1</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> r1 redis-cli <span class="token parameter variable">-p</span> <span class="token number">7001</span>
<span class="token comment"># 查看集群状态</span>
info replication
</code></pre></div><p>结果如下：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:700<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> info replication
<span class="token comment"># Replication</span>
role:master
connected_slaves:2
slave0:ip<span class="token operator">=</span><span class="token number">192.168</span>.150.101,port<span class="token operator">=</span><span class="token number">7002</span>,state<span class="token operator">=</span>online,offset<span class="token operator">=</span><span class="token number">140</span>,lag<span class="token operator">=</span><span class="token number">1</span>
slave1:ip<span class="token operator">=</span><span class="token number">192.168</span>.150.101,port<span class="token operator">=</span><span class="token number">7003</span>,state<span class="token operator">=</span>online,offset<span class="token operator">=</span><span class="token number">140</span>,lag<span class="token operator">=</span><span class="token number">1</span>
master_failover_state:no-failover
master_replid:16d90568498908b322178ca12078114e6c518b86
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:140
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:140
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，当前节点 <code>r1:7001</code> 的角色是 <code>master</code>，有两个 <code>slave</code> 与其连接。</p><ul><li><code>slave0</code>：<code>port</code> 是 <code>7002</code>，也就是 <code>r2</code> 节点。</li><li><code>slave1</code>：<code>port</code> 是 <code>7003</code>，也就是 <code>r3</code> 节点。</li></ul><h4 id="_1-2-3-测试集群" tabindex="-1"><a class="header-anchor" href="#_1-2-3-测试集群"><span>1.2.3 测试集群</span></a></h4><p>依次在 <code>r1</code>、<code>r2</code>、<code>r3</code> 节点上执行下面命令：</p><div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token builtin class-name">set</span> num <span class="token number">123</span>
get num
</code></pre></div><p>你会发现，只有在 <code>r1</code> 这个节点上可以执行 <code>set</code> 命令（<strong>写操作</strong>），其它两个节点只能执行 <code>get</code> 命令（<strong>读操作</strong>）。</p><p>也就是说读写操作已经分离了。</p><h3 id="_1-3-主从同步原理" tabindex="-1"><a class="header-anchor" href="#_1-3-主从同步原理"><span>1.3 主从同步原理</span></a></h3><p>在刚才的主从测试中，我们发现 <code>r1</code> 上写入 Redis 的数据，在 <code>r2</code> 和 <code>r3</code> 上也能看到，这说明主从之间确实完成了数据同步。</p><p>那么这个同步是如何完成的呢？</p><h4 id="_1-3-1-全量同步" tabindex="-1"><a class="header-anchor" href="#_1-3-1-全量同步"><span>1.3.1 全量同步</span></a></h4><p>主从第一次建立连接时，会执行<strong style="color:#fb9b5f;">全量同步</strong>，将 <code>master</code> 节点的所有数据都拷贝给 <code>slave</code> 节点（流程如下图所示）。</p><p><img src="`+p+'" alt="Redis全量同步" loading="lazy"></p><p>这里有一个问题：<code>master</code> 是如何得知 <code>salve</code> 是否是第一次来同步的呢？？？</p><p>有几个概念可以作为判断的依据：</p><ul><li><code>Replication Id</code>：简称 <code>replid</code>，是数据集的标记，<code>replid</code> 一致则是同一数据集。 <ul><li>每个 <code>master</code> 都有唯一的 <code>replid</code>，<code>slave</code> 则会继承 <code>master</code> 节点的 <code>replid</code>。</li></ul></li><li><code>offset</code>：偏移量，随着记录在 <code>repl_baklog</code> 中的数据增多而逐渐增大，<code>slave</code> 完成同步时也会记录当前同步的<code>offset</code>。 <ul><li>如果 <code>slave</code> 的 <code>offset</code> 小于 <code>master</code> 的 <code>offset</code>，则说明 <code>slave</code> 的数据落后于 <code>master</code>，需要更新。</li></ul></li></ul><p>因此 <code>slave</code> 做数据同步，必须向 <code>master</code> 声明自己的 <code>replication id </code> 和 <code>offset</code>，<code>master</code> 才可以判断到底需要同步哪些数据。</p><p>由于我们在执行 <code>slaveof</code> 命令之前，所有 Redis 节点都是 <code>master</code>，都有自己的 <code>replid</code> 和 <code>offset</code>。</p><p>当我们第一次执行 <code>slaveof</code> 命令，与 <code>master</code> 建立主从关系时，发送的 <code>replid</code> 和 <code>offset</code> 都是自己的，与 <code>master</code> 的肯定不一致。</p><p>所以 <code>master</code> 判断发现 <code>slave</code> 发送来的 <code>replid</code> 与自己的不一致，则说明这是一个全新的 <code>slave</code>，就知道要做全量同步了。</p><p><code>master</code> 会将自己的 <code>replid</code> 和 <code>offset</code> 都发送给这个 <code>slave</code>，<code>slave</code> 保存这些信息到本地，自此以后 <code>slave</code> 的 <code>replid </code> 就与 <code>master</code> 一致了。</p><p>因此，<strong style="color:#fb9b5f;"><code>master</code> 判断一个节点是否是第一次同步的依据，就是要看 <code>replid</code> 是否一致</strong>（最新的流程如下图所示）。</p><p><img src="'+d+'" alt="Redis全量同步-新" loading="lazy"></p><p>上图的完整流程描述：</p><ul><li><code>slave</code> 节点请求增量同步。</li><li><code>master</code> 节点判断 <code>replid</code>，发现不一致，拒绝增量同步。</li><li><code>master</code> 将完整内存数据生成 <code>RDB</code>，发送 <code>RDB</code> 到 <code>slave</code>。</li><li><code>slave</code> 清空本地数据，加载 <code>master</code> 的 <code>RDB</code>。</li><li><code>master </code>将 <code>RDB</code> 期间的命令记录在 <code>repl_baklog</code>，并持续将log中的命令发送给 <code>slave</code>。</li><li><code>slave</code> 执行接收到的命令，保持与 <code>master</code> 之间的同步。</li></ul><p>来看下 <code>r1</code> 节点的运行日志：</p><p><img src="'+i+'" alt="节点1运行日志" loading="lazy"></p><p>再看下 <code>r2</code> 节点执行 <code>replicaof</code> 命令时的日志：</p><p><img src="'+r+'" alt="节点2运行日志" loading="lazy"></p><p>与我们描述的完全一致。</p><h4 id="_1-3-2-增量同步" tabindex="-1"><a class="header-anchor" href="#_1-3-2-增量同步"><span>1.3.2 增量同步</span></a></h4><p>全量同步需要先做 RDB，然后将 RDB 文件通过网络传输个 <code>slave</code>，成本太高了。</p><p>因此除了第一次做全量同步，其它大多数时候 <code>slave</code> 与 <code>master</code> 都是在做<strong style="color:#fb9b5f;">增量同步</strong>。</p><p>什么是增量同步？</p><p>就是只更新 <code>slave</code> 与 <code>master</code> 存在差异的部分数据（如下图所示）。</p><p><img src="'+u+'" alt="Redis增量同步" loading="lazy"></p><p>那么 <code>master</code> 怎么知道 <code>slave</code> 与自己的数据差异在哪里呢?</p><h4 id="_1-3-3-repl-baklog-原理" tabindex="-1"><a class="header-anchor" href="#_1-3-3-repl-baklog-原理"><span>1.3.3 <code>repl_baklog</code> 原理</span></a></h4><p><code>master</code> 怎么知道 <code>slave</code> 与自己的数据差异在哪里呢？</p><p>这就要说到全量同步时的 <code>repl_baklog</code> 文件了。</p><p>这个文件是一个固定大小的数组，只不过数组是环形的，也就是说<strong>角标到达数组末尾后，会再次从 0 开始读写</strong>，这样数组头部的数据就会被覆盖。</p><p><code>repl_baklog</code> 中会记录 Redis 处理过的命令及 <code>offset</code>，包括 <code>master</code> 当前的 <code>offset</code>，和 <code>slave</code> 已经拷贝到的 <code>offset</code>：</p><p>未完待续...</p>',79);function g(h,b){return s(),a("div",null,[k,n(" more "),v])}const y=e(m,[["render",g],["__file","index.html.vue"]]),x=JSON.parse('{"path":"/audition/redis/clusters/","title":"集群篇","lang":"zh-CN","frontmatter":{"title":"集群篇","icon":"yuanchenglianjie","category":"面试题","tag":"面试题","timeline":true,"star":true,"description":"此处是一些 Redis 集群的高频面试题（持续更新中...）。 1.集群篇 1.1 主从集群 为什么需要搭建集群？ 单节点 Redis 的并发能力是有上限的，要进一步提高 Redis 的并发能力，就需要搭建主从集群，实现读写分离。 1.1.1 主从集群结构 Redis主从集群结构 如图所示： 集群中有一个 master 节点、两个 slave 节点（现...","head":[["meta",{"property":"og:url","content":"https://SuperChenWenjing.github.io/audition/redis/clusters/"}],["meta",{"property":"og:site_name","content":"陈文景"}],["meta",{"property":"og:title","content":"集群篇"}],["meta",{"property":"og:description","content":"此处是一些 Redis 集群的高频面试题（持续更新中...）。 1.集群篇 1.1 主从集群 为什么需要搭建集群？ 单节点 Redis 的并发能力是有上限的，要进一步提高 Redis 的并发能力，就需要搭建主从集群，实现读写分离。 1.1.1 主从集群结构 Redis主从集群结构 如图所示： 集群中有一个 master 节点、两个 slave 节点（现..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-08T16:03:07.000Z"}],["meta",{"property":"article:author","content":"陈文景"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:modified_time","content":"2024-03-08T16:03:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"集群篇\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-08T16:03:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"陈文景\\",\\"email\\":\\"2646530197@qq.com\\",\\"url\\":\\"https://superchenwenjing.github.io\\"}]}"]],"date":"2024-03-08T16:03:07.000Z"},"headers":[{"level":2,"title":"1.集群篇","slug":"_1-集群篇","link":"#_1-集群篇","children":[{"level":3,"title":"1.1 主从集群","slug":"_1-1-主从集群","link":"#_1-1-主从集群","children":[]},{"level":3,"title":"1.2 搭建主从集群","slug":"_1-2-搭建主从集群","link":"#_1-2-搭建主从集群","children":[]},{"level":3,"title":"1.3 主从同步原理","slug":"_1-3-主从同步原理","link":"#_1-3-主从同步原理","children":[]}]}],"git":{"createdTime":1709913787000,"updatedTime":1709913787000,"contributors":[{"name":"陈文景","email":"2646530197@qq.com","commits":1}]},"readingTime":{"minutes":5.79,"words":1738},"filePathRelative":"audition/redis/clusters/README.md","localizedDate":"2024年3月8日","excerpt":"<p>此处是一些 Redis 集群的高频面试题（持续更新中...）。</p>\\n","autoDesc":true}');export{y as comp,x as data};
