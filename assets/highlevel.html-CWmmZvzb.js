import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as s,f as t}from"./app-Cl5mH8NZ.js";const e={},p=t(`<h2 id="抽象类" tabindex="-1"><a class="header-anchor" href="#抽象类"><span>抽象类</span></a></h2><div class="hint-container tip"><p class="hint-container-title">什么是抽象类和抽象方法？</p><p>被 <code>abstract</code> 关键字修饰的类称为抽象类、被 <code>abstract</code> 关键字修饰的<strong>没有方法体的方法</strong>则称为抽象方法。</p><p>抽象类语法格式：</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token punctuation">[</span>权限修饰符<span class="token punctuation">]</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> 类名<span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token punctuation">[</span>权限修饰符<span class="token punctuation">]</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> 类名 <span class="token keyword">extends</span> 父类<span class="token punctuation">{</span> <span class="token punctuation">}</span>
</code></pre></div><p>抽象方法语法格式：</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token punctuation">[</span>权限修饰符<span class="token punctuation">]</span> <span class="token keyword">abstract</span> 返回值类型 方法名<span class="token punctuation">(</span><span class="token punctuation">[</span>形参列表<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>注意：</strong></p><ul><li><strong>抽象类不能创建对象</strong>。</li><li>抽象类是用来被继承的。</li><li>抽象类中可以没有抽象方法，但是有抽象方法的类一定是抽象类。</li><li>继承抽象类的子类需要实现抽象类中的所有抽象方法，否则自己也要成为抽象类。</li></ul><p><code>abstract</code> 关键字的注意事项：</p><ul><li>不能使用 <code>abstract</code> 关键字修饰变量、代码块、构造器。</li><li>不能使用 <code>abstract</code> 关键字修饰私有方法、静态方法、<code>final</code> 修饰的方法、<code>final</code> 修饰的类。</li></ul></div><h2 id="接口-interface" tabindex="-1"><a class="header-anchor" href="#接口-interface"><span>接口（interface）</span></a></h2><div class="hint-container tip"><p class="hint-container-title">什么是接口？</p><p>接口可以理解为一种规范，定义了一组规则，体现了现实世界中“如果你是/要...则必须...“的思想。</p><p>接口的定义格式：</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> <span class="token keyword">interface</span> 接口名<span class="token punctuation">{</span>
  <span class="token comment">// 接口的成员列表</span>
  <span class="token comment">// 公共的静态常量</span>
  <span class="token comment">// 公共的抽象方法</span>
  <span class="token comment">// 公共的默认方法（JDK1.8 以上）</span>
  <span class="token comment">// 公共的静态方法（JDK1.8 以上）</span>
  <span class="token comment">// 私有方法（JDK1.9 以上）</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>JDK8.0 之前的接口中只允许出现：</strong></p><ul><li>公共的静态常量：其中 <code>public static final</code> 可以省略。</li><li>公共的抽象方法：其中 <code>public abstract</code> 可以省略。</li></ul><p><strong>JDK8.0 的接口中允许声明默认方法和静态方法：</strong></p><ul><li><p>公共的默认方法（使用 <code>default</code> 关键字修饰 - 不能省略）：其中 <code>public</code> 可以省略（但建议保留）。</p><ul><li><p>需要用接口的实现类的对象来调用。</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">default</span> 返回值类型 方法名<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div></li></ul></li><li><p>公共的静态方法（使用 <code>static</code> 关键字修饰 - 不能省略）：其中 <code>public</code> 可以省略（但建议保留）。</p><ul><li><p>接口的静态方法必须用本身的接口名来调用。</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">static</span> 返回值类型 方法名<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div></li></ul></li></ul><p><strong>JDK9.0 的接口中允许声明私有方法：</strong></p><ul><li><p>私有方法（使用 <code>private</code> 关键字修饰 - 不能省略）。</p><ul><li><p>只能在本类中被其他的默认方法或者私有方法访问。</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> 返回值类型 方法名<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div></li></ul></li></ul><p>**补充说明：**接口中没有构造器、没有代码块，因为接口中没有成员变量需要动态初始化。</p><p><strong>注意：</strong></p><ul><li><strong>接口不能创建对象</strong>。</li><li>如果一个类既继承类又实现接口，则继承在前实现在后。</li><li>接口可以被类单实现、也可以多实现（接口可以单继承或多继承其它接口）。</li><li>一个类实现了接口，就必须重写完接口中的全部抽象方法，否则这个类需要被定义成抽象类。</li><li>一个类实现多个接口，多个接口的规范不能冲突。</li><li>一个类实现多个接口，多个接口中有同样的静态方法不冲突。</li><li>一个类继承了父类，同时又实现了接口，父类中和接口中有同名方法，默认用父类的。</li><li>一个类实现了多个接口，多个接口中存在同名的默认方法，可以不冲突，这个类重写该方法即可。</li><li>一个接口继承多个接口，是没有问题的，如果多个接口中存在规范冲突则不能多继承。</li></ul></div><h2 id="内部类" tabindex="-1"><a class="header-anchor" href="#内部类"><span>内部类</span></a></h2><div class="hint-container tip"><p class="hint-container-title">什么是内部类？</p><p>将一个类 A 定义在另一个类 B 的内部，则里面的那个类 A 就称为内部类。</p><p>内部类的分类：</p><ul><li><p>静态内部类。</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">{</span>
  <span class="token comment">// 静态内部类</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 外部类名.内部类名 对象名称 = new 外部类名.内部类构造器();</span>
<span class="token class-name">Outer<span class="token punctuation">.</span>Inner</span> inner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outer<span class="token punctuation">.</span>Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li><li><p>成员内部类。</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">{</span>
  <span class="token comment">// 成员内部类</span>
  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 外部类名.内部类名 对象名称 = new 外部类构造器().new 内部类构造器();</span>
<span class="token class-name">Outer<span class="token punctuation">.</span>Inner</span> inner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li><li><p>局部内部类。</p><p>鸡肋语法、知道即可。</p></li><li><p>匿名内部类。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 格式：</span>
<span class="token comment">// new 类名称 | 抽象类名称 | 接口名称 () {</span>
<span class="token comment">//   重写方法;</span>
<span class="token comment">// };</span>

<span class="token comment">// 范例：</span>
<span class="token class-name">Employee</span> employee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
employee<span class="token punctuation">.</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>匿名内部类的特点总结：</p><ul><li>匿名内部类是一个<strong>没有名字的内部类，同时也代表一个对象</strong>。</li><li><strong>匿名内部类产生的对象类型，相当于是当前<code>new</code>的那个的类型的子类类型</strong>。</li><li>匿名内部类可以作为一个对象，直接传输给方法。</li><li>匿名内部类通常是在开发中调用别人的方法时，别人需要我们写的时候才会定义出来使用。</li><li>匿名内部类还可以通过<code>Lambda</code>表达式实现进一步的简化代码。</li></ul></li></ul></div><h2 id="枚举类" tabindex="-1"><a class="header-anchor" href="#枚举类"><span>枚举类</span></a></h2><div class="hint-container tip"><p class="hint-container-title">什么是枚举类？</p><p>枚举是 Java 中的一种特殊类型。</p><p>枚举的作用：是为了做信息的标志和信息的分类。</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>修饰符 <span class="token keyword">enum</span> 枚举名称 <span class="token punctuation">{</span>
  枚举实例的名称（每个枚举实例都是该枚举类的实例对象）
<span class="token punctuation">}</span>
</code></pre></div><p><strong>枚举类的特征：</strong></p><ul><li>枚举类都是继承了枚举类型 <code>java.lang.Enum</code>。</li><li><strong>枚举都是最终类，不可以被继承</strong>。</li><li><strong>构造器都是私有的，枚举对外不能创建对象</strong>。</li><li>枚举类相当于是多例模式。</li></ul></div><h2 id="注解" tabindex="-1"><a class="header-anchor" href="#注解"><span>注解</span></a></h2><div class="hint-container tip"><p class="hint-container-title">什么是注解？</p><p>Annotation 可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。</p><p>元注解（注解的注解）：</p><ul><li>@Target：用于描述注解的使用范围。 <ul><li>可以通过枚举类型 ElementType 的 10 个常量对象来指定。</li></ul></li><li>@Retention：用于描述注解的生命周期。 <ul><li>可以通过枚举类型 RetentionPolicy 的 3 个常量对象来指定。</li><li>SOURCE（源代码）、CLASS（字节码）、RUNTIME（运行时）。</li><li>唯有 RUNTIME 阶段才能被反射读取到。</li></ul></li><li>@Documented：表明这个注解应该被 JavaDoc 工具记录。</li><li>@Inherited：允许子类继承父类中的注解。</li></ul><p><strong>自定义注解：</strong></p><p>一个完整的注解应该包含三个部分：声明、使用、读取。</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>@元注解
<span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> <span class="token annotation punctuation">@interface</span> 注解名 <span class="token punctuation">{</span>
  <span class="token comment">// 成员列表</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注：需配合反射技术实现（待补充完整）。</p></div>`,10),l=[p];function c(o,i){return n(),s("div",null,l)}const d=a(e,[["render",c],["__file","highlevel.html.vue"]]),k=JSON.parse('{"path":"/notes/java/oop/highlevel.html","title":"高级","lang":"zh-CN","frontmatter":{"title":"高级","icon":"Code","category":"Java","timeline":true,"star":true,"description":"抽象类 什么是抽象类和抽象方法？ 被 abstract 关键字修饰的类称为抽象类、被 abstract 关键字修饰的没有方法体的方法则称为抽象方法。 抽象类语法格式： 抽象方法语法格式： 注意： 抽象类不能创建对象。 抽象类是用来被继承的。 抽象类中可以没有抽象方法，但是有抽象方法的类一定是抽象类。 继承抽象类的子类需要实现抽象类中的所有抽象方法，否则...","head":[["meta",{"property":"og:url","content":"https://SuperChenWenjing.github.io/notes/java/oop/highlevel.html"}],["meta",{"property":"og:site_name","content":"陈文景"}],["meta",{"property":"og:title","content":"高级"}],["meta",{"property":"og:description","content":"抽象类 什么是抽象类和抽象方法？ 被 abstract 关键字修饰的类称为抽象类、被 abstract 关键字修饰的没有方法体的方法则称为抽象方法。 抽象类语法格式： 抽象方法语法格式： 注意： 抽象类不能创建对象。 抽象类是用来被继承的。 抽象类中可以没有抽象方法，但是有抽象方法的类一定是抽象类。 继承抽象类的子类需要实现抽象类中的所有抽象方法，否则..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-07T07:53:09.000Z"}],["meta",{"property":"article:author","content":"陈文景"}],["meta",{"property":"article:modified_time","content":"2024-04-07T07:53:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"高级\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-07T07:53:09.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"陈文景\\",\\"email\\":\\"2646530197@qq.com\\",\\"url\\":\\"https://superchenwenjing.github.io\\"}]}"]],"date":"2024-04-06T07:26:51.000Z"},"headers":[{"level":2,"title":"抽象类","slug":"抽象类","link":"#抽象类","children":[]},{"level":2,"title":"接口（interface）","slug":"接口-interface","link":"#接口-interface","children":[]},{"level":2,"title":"内部类","slug":"内部类","link":"#内部类","children":[]},{"level":2,"title":"枚举类","slug":"枚举类","link":"#枚举类","children":[]},{"level":2,"title":"注解","slug":"注解","link":"#注解","children":[]}],"git":{"createdTime":1712388411000,"updatedTime":1712476389000,"contributors":[{"name":"陈文景","email":"2646530197@qq.com","commits":2}]},"readingTime":{"minutes":5.39,"words":1616},"filePathRelative":"notes/java/oop/highlevel.md","localizedDate":"2024年4月6日","excerpt":"","autoDesc":true}');export{d as comp,k as data};
