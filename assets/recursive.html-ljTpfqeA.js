import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as t,b as s,d as e,f as p}from"./app-CZFwauM-.js";const o={},c=e("p",null,"在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。",-1),i=p(`<p>举个例子，我们来计算阶乘 $n! = 1 \\times 2 \\times 3 \\times \\cdots \\times n$ ，用函数 <code>fact(n)</code> 表示，可以看出:</p><p>$$ fact(n)= n! =1 \\times 2 \\times 3 \\times \\cdots \\times (n -1 ) \\times n \\ = (n - 1)! \\times n = fact(n - 1) \\times n $$</p><p>所以，<code>fact(n)</code> 可以表示为 $n \\times fact(n-1)$，只有 n=1 时需要特殊处理。</p><p>于是，<code>fact(n)</code> 用递归的方式写出来就是:</p><div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">fact</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token keyword">return</span> n <span class="token operator">*</span> fact<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre></div><p>上面就是一个递归函数。可以试试:</p><div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> fact<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token number">1</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> fact<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token number">120</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> fact<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token number">93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</span>
</code></pre></div><p>如果我们计算 <code>fact(5)</code>，可以根据函数定义看到计算过程如下:</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>===&gt; fact(5)
===&gt; 5 *fact(4)
===&gt; 5* (4 *fact(3))
===&gt; 5* (4 *(3* fact(2)))
===&gt; 5 *(4* (3 *(2* fact(1))))
===&gt; 5 *(4* (3 *(2* 1)))
===&gt; 5 *(4* (3 *2))
===&gt; 5* (4 *6)
===&gt; 5* 24
===&gt; 120
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。</p><p>使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈(stack)这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试 <code>fact(1000)</code>:</p><div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> fact<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span>:
  File <span class="token string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="token number">1</span>, <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>
  File <span class="token string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="token number">4</span>, <span class="token keyword">in</span> fact
  <span class="token punctuation">..</span>.
  File <span class="token string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="token number">4</span>, <span class="token keyword">in</span> fact
RuntimeError: maximum recursion depth exceeded <span class="token keyword">in</span> comparison
</code></pre></div><p>解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p><p>尾递归是指，在函数返回的时候，调用自身本身，并且，return 语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p><p>上面的 <code>fact(n)</code> 函数由于 <code>return n * fact(n - 1)</code> 引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中:</p><div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">fact</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> fact_iter<span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">fact_iter</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> product<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> num <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> product
    <span class="token keyword">return</span> fact_iter<span class="token punctuation">(</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> num <span class="token operator">*</span>product<span class="token punctuation">)</span>
</code></pre></div><p>可以看到，<code>return fact_iter(num - 1, num* product)</code> 仅返回递归函数本身，<code>num - 1</code> 和 <code>num * product</code> 在函数调用前就会被计算，不影响函数调用。</p><p><code>fact(5)</code> 对应的 <code>fact_iter(5, 1)</code> 的调用如下:</p><div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>===&gt; fact_iter(5, 1)
===&gt; fact_iter(4, 5)
===&gt; fact_iter(3, 20)
===&gt; fact_iter(2, 60)
===&gt; fact_iter(1, 120)
===&gt; 120
</code></pre></div><p>尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</p><p>遗憾的是，大多数编程语言没有针对尾递归做优化，Python 解释器也没有做优化，所以，即使把上面的 <code>fact(n)</code> 函数改成尾递归方式，也会导致栈溢出。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><p>使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。</p><p>针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。</p><p>Python 标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。</p>`,25);function r(l,u){return a(),t("div",null,[c,s(" more "),i])}const k=n(o,[["render",r],["__file","recursive.html.vue"]]),g=JSON.parse('{"path":"/casual/code/language/python/function/recursive.html","title":"递归函数","lang":"zh-CN","frontmatter":{"title":"递归函数","icon":"refresh","author":"廖雪峰","date":"2020-05-27T00:00:00.000Z","category":"Python","description":"在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。 举个例子，我们来计算阶乘 $n! = 1 \\\\times 2 \\\\times 3 \\\\times \\\\cdots \\\\times n$ ，用函数 fact(n) 表示，可以看出: $$ fact(n)= n! =1 \\\\times 2 \\\\times 3 \\\\times \\\\cdots...","head":[["meta",{"property":"og:url","content":"https://SuperChenWenjing.github.io/casual/code/language/python/function/recursive.html"}],["meta",{"property":"og:site_name","content":"陈文景"}],["meta",{"property":"og:title","content":"递归函数"}],["meta",{"property":"og:description","content":"在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。 举个例子，我们来计算阶乘 $n! = 1 \\\\times 2 \\\\times 3 \\\\times \\\\cdots \\\\times n$ ，用函数 fact(n) 表示，可以看出: $$ fact(n)= n! =1 \\\\times 2 \\\\times 3 \\\\times \\\\cdots..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-08T16:03:07.000Z"}],["meta",{"property":"article:author","content":"廖雪峰"}],["meta",{"property":"article:published_time","content":"2020-05-27T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-08T16:03:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"递归函数\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-05-27T00:00:00.000Z\\",\\"dateModified\\":\\"2024-03-08T16:03:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"廖雪峰\\"}]}"]]},"headers":[{"level":2,"title":"小结","slug":"小结","link":"#小结","children":[]}],"git":{"createdTime":1709913787000,"updatedTime":1709913787000,"contributors":[{"name":"陈文景","email":"2646530197@qq.com","commits":1}]},"readingTime":{"minutes":3.16,"words":948},"filePathRelative":"casual/code/language/python/function/recursive.md","localizedDate":"2020年5月27日","excerpt":"<p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p>\\n","autoDesc":true}');export{k as comp,g as data};
