import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as p,c as i,b as l,d as n,e as a,a as c,f as t}from"./app-DmHiIdcO.js";const r="/assets/RabbitMQ消息丢失的场景-S92-3axY.png",u="/assets/生产者确认机制-BAIYm57L.png",d="/assets/异常交换机-C3QPZ3TJ.png",g="/assets/私信交换机代码实现-BB15SUFE.png",m="/assets/死信交换机-f4HwxH11.png",b="/assets/TTL实现代码-1mQpT0ad.png",k="/assets/TTL-BqLUjHfL.png",h="/assets/DelayExchange插件-DBz6rWMl.png",_="/assets/惰性队列-BahBTtbn.png",M="/assets/镜像集群-BOFPXTpS.png",Q={},y=n("div",{class:"hint-container note"},[n("p",{class:"hint-container-title"},"注"),n("p",null,"此处是一些 RabbitMQ 高频面试题（持续更新中...）。")],-1),v=t('<h2 id="面试题汇总" tabindex="-1"><a class="header-anchor" href="#面试题汇总"><span>面试题汇总</span></a></h2><div class="hint-container warning"><p class="hint-container-title">RabbitMQ 能做什么？</p><p>异步发送（验证码、手机短信、邮件、...）。</p><p>MySQL 和 Redis、ES 之间的数据同步（双写一致性）。</p><p>分布式事务。</p><p>削峰填谷。</p><p>......。</p></div><div class="hint-container info"><p class="hint-container-title">RabbitMQ 如何保证消息不丢失？</p><blockquote><p><strong>可能出现消息丢失的节点</strong>：</p><p><img src="'+r+'" alt="RabbitMQ消息丢失的场景" loading="lazy"></p><p><strong>生产者确认机制</strong>：</p><p>RabbitMQ 提供了 <code>publisher confirm</code> 机制来避免消息发送到 MQ 过程中丢失。</p><p>消息发送到 MQ 以后，会返回一个结果给发送者，表示消息是否处理成功。</p><p><img src="'+u+`" alt="生产者确认机制" loading="lazy"></p><p><strong>消息失败之后如何处理呢？</strong></p><ul><li>回调方法即时重发。</li><li>记录日志。</li><li>保存到数据库然后定时重发，成功发送后即刻删除表中的数据。</li></ul><p><strong>消息持久化（确保 MQ 消息不丢失）</strong>：</p><p>RabbitMQ 默认是内存存储消息，开启持久化功能可以确保缓存在 RabbitMQ 中的消息不丢失。</p><ol><li><p>交换机持久化：</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">simpleExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// 三个参数：交换机名称、是否持久化、当没有 queue 与其绑定时是否自动删除</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span><span class="token string">&quot;simple.direct&quot;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li><li><p>队列持久化：</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">simpleQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// 使用 QueueBuilder 构建队列，durable 就是持久化的</span>
  <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span><span class="token string">&quot;simple.queue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li><li><p>消息持久化：</p><p>SpringAMQP 中的的消息默认是持久的，可以通过 MessageProperties 中的 DeliveryMode 来指定的。</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token class-name">MessageBuilder</span>
  <span class="token punctuation">.</span><span class="token function">withBody</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 消息体</span>
  <span class="token punctuation">.</span><span class="token function">setDeliveryMode</span><span class="token punctuation">(</span><span class="token class-name">MessageDeliveryMode</span><span class="token punctuation">.</span><span class="token constant">PERSISTENT</span><span class="token punctuation">)</span> <span class="token comment">// 持久化</span>
  <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ol><p><strong>消费者确认机制</strong>：</p><p>RabbitMQ 支持消费者确认机制，就是消费者处理完消息后可以向 RabbitMQ 发送 <code>ack</code> 回执，RabbitMQ 收到 <code>ack</code> 回执后才会删除该消息。</p><p>而 SpringAMQP 则允许配置三种确认模式：</p><ul><li>manual：手动 ack，需要在业务代码结束后，调用 api 发送 ack。</li><li>auto：自动 ack，由 Spring 监测 listener 代码是否出现异常，没有异常则返回 ack，否则抛出异常则返回 nack。</li><li>none：关闭 ack，RabbitMQ 假定消费者获取消息后会成功处理，因此消息投递后立即被删除。</li></ul><p>我们可以利用 Spring 的 <code>retry</code> 机制，在消费者出现异常时利用本地重试，设置重试次数，当次数达到了以后，如果消息依然失败，将消息投递到异常交换机，交由人工处理。</p><p><img src="`+d+'" alt="异常交换机" loading="lazy"></p><p><strong>参考回答</strong>：</p><ul><li>开启生产者确认机制，确保生产者的消息能到达队列。</li><li>开启持久化功能，确保消息未消费前在队列中不会丢失。</li><li>开启消费者确认机制为 auto，由 spring 确认消息处理成功后完成 ack。</li><li>开启消费者失败重试机制，多次重试失败后将消息投递到异常交换机，交由人工处理。</li></ul></blockquote></div><div class="hint-container info"><p class="hint-container-title">RabbitMQ 消息的重复消费问题如何解决的？</p><blockquote><p>产生的原因：网络抖动、消费者挂了（重启后）。</p><p>解决方案：</p><ul><li>每条消息设置一个唯一的标识 ID。</li><li>幂等方案 - 分布式锁、数据库锁（悲观锁、乐观锁）。</li></ul></blockquote></div>',4),R={class:"hint-container info"},f=n("p",{class:"hint-container-title"},"RabbitMQ 中死信交换机？RabbitMQ 延迟队列有了解过吗？",-1),T=t('<p>延迟队列：进入队列的消息会被延迟消费的队列。</p><p>应用场景：超时订单、限时优惠、定时发布。</p><p><strong><mark>延迟队列 = 死信交换机 + TTL（生存时间）。</mark></strong></p><p>当一个队列中的消息满足下列情况之一时，可以成为<mark>死信（dead letter）</mark>：</p><ul><li>消费者使用 <code>basic.reject</code> 或 <code>basic.nack</code> 声明消费失败，并且消息的 <code>requeue</code> 参数设置为 <code>false</code>。</li><li>消息是一个过期消息，超时无人消费。</li><li>要投递的队列消息堆积满了，最早的消息可能成为死信。</li></ul><p>如果该队列配置了 <code>dead-letter-exchange</code> 属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为死信交换机（Dead Letter Exchange）简称 DLX。</p><p><img src="'+g+'" alt="私信交换机代码实现" loading="lazy"></p><p><img src="'+m+'" alt="死信交换机" loading="lazy"></p><p><strong>TTL（Time-To-Live）</strong>：</p><p>如果一个队列中的消息 TTL 结束了，但仍未消费，则会变为死信，TTL 超时分为两种情况：</p><ul><li>消息所在的队列设置了存活时间。</li><li>消息本身设置了存活时间。</li></ul><p><img src="'+b+'" alt="TTL实现代码" loading="lazy"></p><p><img src="'+k+'" alt="TTL" loading="lazy"></p><p><strong>延迟队列插件</strong>：</p><p>DelayExchange 插件，需要安装在 RabbitMQ 的插件目录中。</p>',15),q={href:"https://www.rabbitmq.com/community-plugins.html",target:"_blank",rel:"noopener noreferrer"},x=n("p",null,"DelayExchange 的本质还是官方的三种交换机，只是添加了延迟功能。",-1),E=n("p",null,[a("因此使用时只需要声明一个交换机，交换机的类型可以是任意类型，然后设定 "),n("code",null,"delayed"),a(" 属性为 "),n("code",null,"true"),a(" 即可。")],-1),L=n("p",null,[n("img",{src:h,alt:"DelayExchange插件",loading:"lazy"})],-1),S=t('<div class="hint-container info"><p class="hint-container-title">RabbitMQ 如果有 100 万消息堆积在 RabbitMQ 如何解决（消息堆积怎么解决）？</p><blockquote><p><strong>原因</strong>：当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是消息堆积问题。</p><p><strong>解决消息堆积有三种种思路</strong>：</p><ul><li>加更多消费者，提高消费速度。</li><li>在消费者内开启线程池加快消息处理速度。</li><li>扩大队列容积，提高堆积上限。</li></ul><p><strong>惰性队列</strong>（惰性队列的特征如下）：</p><ul><li>接收到消息后直接存入磁盘而非内存。</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存。</li><li>支持数百万条的消息存储。</li></ul><p><img src="'+_+'" alt="惰性队列" loading="lazy"></p><p><strong>参考回答</strong>：</p><ul><li>提高消费者的消费能力，可以使用多线程消费任务。</li><li>增加更多的消费者，提高消息的消费速度。</li><li>可以使用 RabbitMQ 的惰性队列，惰性队列主要的好处是：</li><li>接收到消息后直接存入磁盘而非内存。</li><li>消费者要消费消息时才会从磁盘中读取消息并加载到内存中。</li><li>支持数百万条消息的存储。</li></ul></blockquote></div><div class="hint-container info"><p class="hint-container-title">RabbitMQ 的高可用机制有了解过吗？</p><blockquote><p>在生产环境下，使用集群来保证高可用性。</p><p>普通集群、<mark>镜像集群</mark>、仲裁队列。</p><p>镜像集群：</p><img src="'+M+'" alt="镜像集群" style="zoom:50%;"></blockquote></div><div class="hint-container info"><p class="hint-container-title">。</p><blockquote></blockquote></div>',3);function B(j,w){const s=o("ExternalLinkIcon");return p(),i("div",null,[y,l(" more "),v,n("div",R,[f,n("blockquote",null,[T,n("p",null,[a("RabbitMQ 有一个官方的插件社区："),n("a",q,[a("https://www.rabbitmq.com/community-plugins.html"),c(s)])]),x,E,L])]),S])}const N=e(Q,[["render",B],["__file","index.html.vue"]]),P=JSON.parse('{"path":"/audition/rabbitmq/","title":"RabbitMQ","lang":"zh-CN","frontmatter":{"title":"RabbitMQ","icon":"rabbitmq","category":"面试题","tag":"面试题","timeline":true,"star":true,"description":" 注 此处是一些 RabbitMQ 高频面试题（持续更新中...）。 面试题汇总 RabbitMQ 能做什么？ 异步发送（验证码、手机短信、邮件、...）。 MySQL 和 Redis、ES 之间的数据同步（双写一致性）。 分布式事务。 削峰填谷。 ......。 RabbitMQ 如何保证消息不丢失？ 可能出现消息丢失的节点： RabbitMQ消息丢...","head":[["meta",{"property":"og:url","content":"https://SuperChenWenjing.github.io/audition/rabbitmq/"}],["meta",{"property":"og:site_name","content":"陈文景"}],["meta",{"property":"og:title","content":"RabbitMQ"}],["meta",{"property":"og:description","content":" 注 此处是一些 RabbitMQ 高频面试题（持续更新中...）。 面试题汇总 RabbitMQ 能做什么？ 异步发送（验证码、手机短信、邮件、...）。 MySQL 和 Redis、ES 之间的数据同步（双写一致性）。 分布式事务。 削峰填谷。 ......。 RabbitMQ 如何保证消息不丢失？ 可能出现消息丢失的节点： RabbitMQ消息丢..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-05T06:40:05.000Z"}],["meta",{"property":"article:author","content":"陈文景"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:modified_time","content":"2024-05-05T06:40:05.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RabbitMQ\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-05T06:40:05.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"陈文景\\",\\"email\\":\\"2646530197@qq.com\\",\\"url\\":\\"https://superchenwenjing.github.io\\"}]}"]],"date":"2024-05-05T02:49:25.000Z"},"headers":[{"level":2,"title":"面试题汇总","slug":"面试题汇总","link":"#面试题汇总","children":[]}],"git":{"createdTime":1714877365000,"updatedTime":1714891205000,"contributors":[{"name":"陈文景","email":"2646530197@qq.com","commits":3}]},"readingTime":{"minutes":5.56,"words":1667},"filePathRelative":"audition/rabbitmq/README.md","localizedDate":"2024年5月5日","excerpt":"<div class=\\"hint-container note\\">\\n<p class=\\"hint-container-title\\">注</p>\\n<p>此处是一些 RabbitMQ 高频面试题（持续更新中...）。</p>\\n</div>\\n","autoDesc":true}');export{N as comp,P as data};
