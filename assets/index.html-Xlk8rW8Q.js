import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as i,b as n,d as o,f as l}from"./app-BsynsZlL.js";const c="/assets/DQL语句的执行顺序-Br4wtE5f.png",a="/assets/SQL执行计划-CG5sjQmg.png",s="/assets/额外的建议-KWE-eEwk.png",p="/assets/MySQL支持的存储引擎-Ri5gLc8p.png",r="/assets/聚集索引和二级索引-FBBqM87v.png",d="/assets/回表查询-DyXftnNv.png",u="/assets/并发事务带来的问题-B7Pg806L.png",k="/assets/事务的隔离级别-KLGabXmt.png",g="/assets/MySQL主从同步的原理-BytfTIK1.png",m="/assets/分库分表策略-BWBPHcoP.png",h={},y=o("div",{class:"hint-container note"},[o("p",{class:"hint-container-title"},"注"),o("p",null,"此处是一些 MySQL 高频面试题（持续更新中...）。")],-1),L=l('<h2 id="面试题汇总" tabindex="-1"><a class="header-anchor" href="#面试题汇总"><span>面试题汇总</span></a></h2><h3 id="优化" tabindex="-1"><a class="header-anchor" href="#优化"><span>优化</span></a></h3><div class="hint-container info"><p class="hint-container-title">DQL 语句的执行顺序？</p><blockquote><p><img src="'+c+'" alt="DQL语句的执行顺序" loading="lazy"></p></blockquote></div><div class="hint-container info"><p class="hint-container-title">在 MySQL 中如何定位慢查询？</p><blockquote><p><strong>原因</strong>：</p><ul><li>聚合查询。</li><li>多表查询。</li><li>表数据量过大查询。</li><li>深度分页查询。</li></ul><p><strong>表现</strong>：页面加载过慢、接口压测响应时间过长（例如：超过 1s）。</p><p><strong>定位</strong>：</p><ul><li><p>开源工具：</p><ul><li><p>调试工具：Arthas。</p></li><li><p>运维工具：Prometheus、Skywalking。</p></li></ul></li><li><p>配置 MySQL 自带慢查询日志（<code>/etc/my.cnf</code>）：</p><ul><li>开启慢查询日志：<code>slow_query_log=1</code>（默认是 0 - 关闭状态）。</li><li>设置慢查询日志：<code>long_query_time=2</code>（SQL 执行超过 2 秒的则是慢查询 SQL - 默认 10 秒）。</li></ul></li></ul></blockquote></div><div class="hint-container info"><p class="hint-container-title">如何分析 SQL 执行慢的原因？</p><blockquote><p>SQL 执行计划：<code>explain</code>、<code>desc</code>（命令获取 MySQL 如何执行 SELECT 语句的信息）。</p><p><img src="'+a+'" alt="SQL执行计划" loading="lazy"></p><p>type 字段表示这条 SQL 的连接的类型，性能由好到差为：</p><ul><li>system：查询系统中的表。</li><li>const：根据主键查询。</li><li>eq_ref：主键索引查询或唯一索引查询。</li><li>ref：索引查询。</li><li>range：范围查询。</li><li>index：索引树扫描（<mark>避免出现</mark>）。</li><li>all：全盘扫描（<mark>避免出现</mark>）。</li></ul><p><img src="'+s+'" alt="额外的建议" loading="lazy"></p></blockquote><p>参考回答：</p><blockquote><p>可以采用 MySQL 自带的分析工具 EXPLAIN 来查询 SELECT 语句的执行计划：</p><ul><li>通过 key 和 key_len 字段检查是否命中了索引（索引本身是否存在有失效的情况）。</li><li>通过 type 字段查看 SQL 是否有进一步的优化空间，是否存在全索引扫描或全盘扫描。</li><li>通过 extra 字段的额外建议判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复。</li></ul></blockquote></div><div class="hint-container info"><p class="hint-container-title">MYSQL 支持的存储引擎有哪些？它们有什么区别？</p><blockquote><p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。</p><p>存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。</p><p><img src="'+p+'" alt="MySQL支持的存储引擎" loading="lazy"></p><p>InnoDB 存储引擎：支持事务、外键、表级锁和行级锁（MySQL 5.5 之后的默认存储引擎）。</p><p>MyISAM 是早期的存储引擎：它不支持事务、只有表级锁、也没有外键（用的不多）。</p><p>Memory 主要把数据存储在内存中：支持表级锁、没有外键、没有事务（用的也不多）。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">什么是索引？有了解过索引吗？</p><blockquote><p>索引（index）是帮助 MySQL 高效获取数据的一种<strong>有序</strong>的数据结构（不需要全标扫描）。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">索引的底层数据结构了解过嘛？</p><blockquote><p>MySQL 的 InnoDB 引擎采用的是 B+ 树的数据结构来存储索引的。</p><p>非叶子节点存储指针、叶子节点存储数据、叶子节点是一个双向循环链表。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">B 树和 B+ 树有什么区别？</p><blockquote><p>Tips：B+Tree 是在 BTree 基础上的一种优化。</p><p>B 树与 B+ 树的对比：</p><ol><li>磁盘读写代价 B+ 树更低。</li><li>查询效率 B+ 树更加稳定。</li><li>B+ 树便于扫库和区间查询。</li></ol></blockquote></div><div class="hint-container info"><p class="hint-container-title">什么是聚集索引和二级索引？</p><blockquote><p>聚集索引：将数据存储与索引放到了一块，索引结构的叶子节点保存了整行的数据（有且只有一个）。</p><p>二级索引：将数据与索引分开存储，索引结构的叶子节点关联的是对应行的主键值（可以有多个）。</p><p>聚集索引选取规则：</p><ol><li>如果存在主键，则主键索引就是聚集索引。</li><li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li><li>如果表没有主键，也没有合适的唯一（UNIQUE）索引，则 InnoDB 存储引擎会自动生成一个 <code>rowid</code> 作为隐藏的聚集索引。</li></ol><p><img src="'+r+'" alt="聚集索引和二级索引" loading="lazy"></p></blockquote></div><div class="hint-container info"><p class="hint-container-title">什么是回表查询？</p><blockquote><p>通过二级索引找到对应的主键值，然后到聚集索引中查找整行数据，这个过程就是回表查询。</p><p><img src="'+d+`" alt="回表查询" loading="lazy"></p></blockquote></div><div class="hint-container info"><p class="hint-container-title">什么是覆盖索引？</p><blockquote><p>覆盖索引是指：查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到（不需要回表查询）。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">MySQL 超大分页怎么处理？</p><blockquote><p>可以通过覆盖索引加子查询的方式来解决。</p><div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_sku t<span class="token punctuation">,</span>  <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> tb_sku <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">9000000</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> a <span class="token keyword">where</span> t<span class="token punctuation">.</span>id <span class="token operator">=</span> a<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre></div><p>在数据量比较大时，如果进行 <code>limit</code> 分页查询，在查询时，越往后，分页查询效率越低。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">索引创建原则有哪些？</p><blockquote><p>主键索引。</p><p>唯一索引。</p><p>复合索引（根据业务情况创建的索引）。</p><p><strong>索引创建的规则如下</strong>：</p><ol><li>针对于数据量较大，且查询比较频繁的表建立索引（一般单表超过10万数据（增加用户体验））- <mark>重点</mark>。</li><li>针对于常作为查询条件（<code>where</code>）、排序（<code>order by</code>）、分组（<code>group by</code>）操作的字段建立索引 - <mark>重点</mark>。</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率 - <mark>重点</mark>。</li><li>如果索引列不能存储 <code>NULL</code> 值，请在创建表时使用 <code>NOT NULL</code> 约束它。当优化器知道每列是否包含 <code>NULL</code> 值时，它可以更好地确定哪个索引最有效地用于查询。</li></ol><p>注意：要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率 - <mark>重点</mark>。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">什么情况下索引会失效？</p><blockquote><p>首先通过 <code>explain</code> 命令查看 SQL 语句执行计划。</p><ol><li>违反最左前缀法则（联合索引的情况下）： <ul><li>指的是查询从索引的最左前列开始，并且不跳过索引中的列（索引生效）。</li><li>违反最左前缀法则（索引失效）。</li><li>如果符合最左前缀法则，但是出现跳跃某一列，则只有最左列的索引生效（最左列的部分生效）。</li></ul></li><li>如果在添加了索引的字段上进行了运算操作则索引会失效。</li><li>字符串不加单引号会造成索引失效（只要发生了类型转换就会导致索引失效）。</li><li>模糊查询的时候，如果 % 号在前面也会导致索引失效。</li></ol></blockquote></div><div class="hint-container info"><p class="hint-container-title">谈一谈你对 SQL 的优化的经验。</p><blockquote><p>表的设计优化（参考阿里开发手册《嵩山版》）：</p><ul><li>比如设置合适的数值（<code>tinyint</code>、<code>int</code>、<code>bigint</code>）- 要根据实际情况选择。</li><li>比如设置合适的字符串类型（<code>char</code>、<code>varchar</code>）<code>char</code> 定长效率高、<code>varchar</code> 可变长度，效率稍低。</li></ul><p>索引优化（参考索引创建原则和索引失效的情况）。</p><p>SQL 语句优化：</p><ul><li>SELECT 语句务必指明字段名称（避免直接使用 <code>select *</code>）。</li><li>SQL 语句要避免造成索引失效的写法。</li><li>尽量用 <code>union all</code> 代替 <code>union</code>（<code>union</code> 会多一次过滤 - 效率低）。</li><li>避免在 <code>where</code> 子句中对字段进行表达式操作。</li><li>Join 优化能用 <code>inner join</code> 就不用 <code>left join</code>、<code>right join</code>，如必须使用，一定要以小表为驱动，内连接会对两个表进行优化，优先把小表放到外边，把大表放到里边（<code>left join</code> 或 <code>right join</code> 不会重新调整顺序）。</li></ul><p>集群优化（主从复制、读写分离）：</p><ul><li>如果数据库的使用场景读的操作比较多的时候，为了避免写的操作所造成的性能影响，可以采用读写分离的架构。</li><li>读写分离解决的是，数据库的写入，影响了查询的效率。</li></ul><p>分库分表。</p></blockquote></div><h3 id="其它" tabindex="-1"><a class="header-anchor" href="#其它"><span>其它</span></a></h3><div class="hint-container info"><p class="hint-container-title">事物的特性是什么？ACID 是什么？</p><blockquote><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p><strong>原子性</strong>（<mark>A</mark>tomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</p><p><strong>一致性</strong>（<mark>C</mark>onsistency）：事务完成时，必须使所有的数据都保持一致状态。</p><p><strong>隔离性</strong>（<mark>I</mark>solation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</p><p><strong>持久性</strong>（<mark>D</mark>urability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">并发事务会带来哪些问题？怎么解决这些问题？MySQL 的默认隔离级别是？</p><blockquote><p>并发事务问题：脏读、不可重复读、幻读。</p><p><img src="`+u+'" alt="并发事务带来的问题" loading="lazy"></p><p>隔离级别：读未提交、读已提交、<mark>可重复读</mark>（默认）、串行化。</p><p><img src="'+k+'" alt="事务的隔离级别" loading="lazy"></p><p>注意：事务隔离级别越高，数据越安全，但是性能越低！</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">undo log 和 redo log 的区别。</p><blockquote><p><code>redo log</code>：记录的是数据页的物理变化，服务宕机可用来同步数据。</p><p><code>undo log</code>：记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据。</p><p><code>redo log</code> 保证了事务的持久性、<code>undo log</code> 保证了事务的原子性和一致性。</p><p><strong>参考回答</strong>：</p><p>其中 <code>redo log</code> 日志记录的是数据页的物理变化，服务宕机可以用来恢复数据，而 <code>undo log</code> 不同，它主要记录的是逻辑日志，当事务回滚时，通过逆向操作恢复原来的数据，比如我们删除一条数据的时候，就会在 <code>undo log</code> 日志文件中新增一条 <code>delete</code> 语句，如果发生回滚就执行逆向操作。</p><p><code>redo log</code> 保证了事务的持久性、<code>undo log</code> 保证了事务的原子性和一致性。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">事务中的隔离性是如何保证的？</p><blockquote><p>事务的隔离性是由锁和 MVCC 实现的。</p><p><strong>锁</strong>：排他锁（如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁）。</p><p><strong>MVCC</strong> : 多版本并发控制。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">你解释一下 MVCC ？</p><blockquote><p>全称 <mark>M</mark>ulti-<mark>V</mark>ersion <mark>C</mark>oncurrency <mark>C</mark>ontrol（多版本并发控制）。</p><p>指维护一个数据的多个版本，使得读写操作没有冲突。</p><p>MVCC 的具体实现，主要依赖于数据库记录中的隐式字段、<code>undo log</code> 日志、<code>readView</code>。</p><p><strong>参考回答</strong>：</p><p>事务的隔离性是由锁和 MVCC 实现的。</p><p>其中 MVCC 的意思是多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，它的底层实现主要分为三个部分：第一个是隐藏字段、第二个是 <code>undo log</code> 日志、第三个是 <code>readView</code> 读视图。</p><p>隐藏字段：是指在 MySQL 中给每个表都设置了隐藏的字段，有一个是 <code>trx_id</code>（事务 ID），记录每一次操作的事务 ID，是自增的、另一个字段是 <code>roll_pointer</code>（回滚指针），指向上一个版本的事务版本记录的地址。</p><p><code>undo log</code>：主要的作用是记录回滚日志，存储老版本的数据，在内部会形成一个版本链，在多个事务并行操作某一行记录时，记录不同事务修改数据的版本，通过 <code>roll_pointer</code> 指针形成一个链表。</p><p><code>readView</code>：解决的事一个事务查询选择版本的问题，在内部定义了一些匹配规则和当前的一些事务 ID 判断访问哪个版本的数据，不同的隔离级别快照读是不一样的，最终的访问结果不一样。如果是读已提交的隔离级别，那每一次执行快照读时生成 <code>readView</code>，如果是可重复读隔离级别，则仅在事务中每一次执行快照读时才会生成 <code>readView</code> 供后续复用。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">MySQL 主从同步原理？。</p><blockquote><p>MySQL 主从复制的核心就是二进制日志。</p><blockquote><p>二进制日志（BINLOG）：记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但不包括数据查询（SELECT、SHOW）语句。</p></blockquote><p>复制分成三步：</p><ol><li>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</li><li>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</li><li>Slave 重做中继日志中的事件，将改变反映它自己的数据。</li></ol><p><img src="'+g+'" alt="MySQL主从同步的原理" loading="lazy"></p></blockquote></div><div class="hint-container info"><p class="hint-container-title">MySQL 分库分表如何实现？</p><blockquote><p>分库分表的时机：</p><ol><li>前提：项目业务数据逐渐增多，或业务发展比较迅速（单表的数据量达 1000W 或 20G 以后）。</li><li>优化已解决不了性能问题（主从读写分离、查询索引、…）。</li><li>IO 瓶颈（磁盘 IO、网络 IO）、CPU 瓶颈（聚合查询、连接数太多）。</li></ol><p><img src="'+m+'" alt="分库分表策略" loading="lazy"></p><p>第三方插件实现分库分表：ShardingSphere、Mycat。</p></blockquote></div>',24);function b(q,v){return t(),i("div",null,[y,n(" more "),L])}const _=e(h,[["render",b],["__file","index.html.vue"]]),f=JSON.parse('{"path":"/audition/mysql/","title":"MySQL","lang":"zh-CN","frontmatter":{"title":"MySQL","icon":"MYSQL8","category":"面试题","tag":"面试题","timeline":true,"star":true,"description":" 注 此处是一些 MySQL 高频面试题（持续更新中...）。 面试题汇总 优化 DQL 语句的执行顺序？ DQL语句的执行顺序 在 MySQL 中如何定位慢查询？ 原因： 聚合查询。 多表查询。 表数据量过大查询。 深度分页查询。 表现：页面加载过慢、接口压测响应时间过长（例如：超过 1s）。 定位： 开源工具： 调试工具：Arthas。 运维工具：...","head":[["meta",{"property":"og:url","content":"https://SuperChenWenjing.github.io/audition/mysql/"}],["meta",{"property":"og:site_name","content":"陈文景"}],["meta",{"property":"og:title","content":"MySQL"}],["meta",{"property":"og:description","content":" 注 此处是一些 MySQL 高频面试题（持续更新中...）。 面试题汇总 优化 DQL 语句的执行顺序？ DQL语句的执行顺序 在 MySQL 中如何定位慢查询？ 原因： 聚合查询。 多表查询。 表数据量过大查询。 深度分页查询。 表现：页面加载过慢、接口压测响应时间过长（例如：超过 1s）。 定位： 开源工具： 调试工具：Arthas。 运维工具：..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-04T06:46:58.000Z"}],["meta",{"property":"article:author","content":"陈文景"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:modified_time","content":"2024-05-04T06:46:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-04T06:46:58.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"陈文景\\",\\"email\\":\\"2646530197@qq.com\\",\\"url\\":\\"https://superchenwenjing.github.io\\"}]}"]],"date":"2024-03-08T16:03:07.000Z"},"headers":[{"level":2,"title":"面试题汇总","slug":"面试题汇总","link":"#面试题汇总","children":[{"level":3,"title":"优化","slug":"优化","link":"#优化","children":[]},{"level":3,"title":"其它","slug":"其它","link":"#其它","children":[]}]}],"git":{"createdTime":1709913787000,"updatedTime":1714805218000,"contributors":[{"name":"陈文景","email":"2646530197@qq.com","commits":5}]},"readingTime":{"minutes":11.54,"words":3463},"filePathRelative":"audition/mysql/README.md","localizedDate":"2024年3月8日","excerpt":"<div class=\\"hint-container note\\">\\n<p class=\\"hint-container-title\\">注</p>\\n<p>此处是一些 MySQL 高频面试题（持续更新中...）。</p>\\n</div>\\n","autoDesc":true}');export{_ as comp,f as data};
