import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as n,b as o,d as i,f as l}from"./app-BZ8IARbX.js";const a="/assets/DQL语句的执行顺序-Br4wtE5f.png",c="/assets/SQL执行计划-CG5sjQmg.png",s="/assets/额外的建议-KWE-eEwk.png",p="/assets/MySQL支持的存储引擎-Ri5gLc8p.png",r="/assets/聚集索引和二级索引-FBBqM87v.png",d="/assets/回表查询-DyXftnNv.png",h={},u=i("div",{class:"hint-container note"},[i("p",{class:"hint-container-title"},"注"),i("p",null,"此处是一些 MySQL 高频面试题（持续更新中...）。")],-1),m=l('<h2 id="面试题汇总" tabindex="-1"><a class="header-anchor" href="#面试题汇总"><span>面试题汇总</span></a></h2><h3 id="优化" tabindex="-1"><a class="header-anchor" href="#优化"><span>优化</span></a></h3><div class="hint-container info"><p class="hint-container-title">DQL 语句的执行顺序？</p><blockquote><p><img src="'+a+'" alt="DQL语句的执行顺序" loading="lazy"></p></blockquote></div><div class="hint-container info"><p class="hint-container-title">在 MySQL 中如何定位慢查询？</p><blockquote><p><strong>原因</strong>：</p><ul><li>聚合查询。</li><li>多表查询。</li><li>表数据量过大查询。</li><li>深度分页查询。</li></ul><p><strong>表现</strong>：页面加载过慢、接口压测响应时间过长（例如：超过 1s）。</p><p><strong>定位</strong>：</p><ul><li><p>开源工具：</p><ul><li><p>调试工具：Arthas。</p></li><li><p>运维工具：Prometheus、Skywalking。</p></li></ul></li><li><p>配置 MySQL 自带慢查询日志（<code>/etc/my.cnf</code>）：</p><ul><li>开启慢查询日志：<code>slow_query_log=1</code>（默认是 0 - 关闭状态）。</li><li>设置慢查询日志：<code>long_query_time=2</code>（SQL 执行超过 2 秒的则是慢查询 SQL - 默认 10 秒）。</li></ul></li></ul></blockquote></div><div class="hint-container info"><p class="hint-container-title">如何分析 SQL 执行慢的原因？</p><blockquote><p>SQL 执行计划：<code>explain</code>、<code>desc</code>（命令获取 MySQL 如何执行 SELECT 语句的信息）。</p><p><img src="'+c+'" alt="SQL执行计划" loading="lazy"></p><p>type 字段表示这条 SQL 的连接的类型，性能由好到差为：</p><ul><li>system：查询系统中的表。</li><li>const：根据主键查询。</li><li>eq_ref：主键索引查询或唯一索引查询。</li><li>ref：索引查询。</li><li>range：范围查询。</li><li>index：索引树扫描（<mark>避免出现</mark>）。</li><li>all：全盘扫描（<mark>避免出现</mark>）。</li></ul><p><img src="'+s+'" alt="额外的建议" loading="lazy"></p></blockquote><p>参考回答：</p><blockquote><p>可以采用 MySQL 自带的分析工具 EXPLAIN 来查询 SELECT 语句的执行计划：</p><ul><li>通过 key 和 key_len 字段检查是否命中了索引（索引本身是否存在有失效的情况）。</li><li>通过 type 字段查看 SQL 是否有进一步的优化空间，是否存在全索引扫描或全盘扫描。</li><li>通过 extra 字段的额外建议判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复。</li></ul></blockquote></div><div class="hint-container info"><p class="hint-container-title">MYSQL 支持的存储引擎有哪些？它们有什么区别？</p><blockquote><p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。</p><p>存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。</p><p><img src="'+p+'" alt="MySQL支持的存储引擎" loading="lazy"></p><p>InnoDB 存储引擎：支持事务、外键、表级锁和行级锁（MySQL 5.5 之后的默认存储引擎）。</p><p>MyISAM 是早期的存储引擎：它不支持事务、只有表级锁、也没有外键（用的不多）。</p><p>Memory 主要把数据存储在内存中：支持表级锁、没有外键、没有事务（用的也不多）。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">什么是索引？有了解过索引吗？</p><blockquote><p>索引（index）是帮助 MySQL 高效获取数据的一种<strong>有序</strong>的数据结构（不需要全标扫描）。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">索引的底层数据结构了解过嘛？</p><blockquote><p>MySQL 的 InnoDB 引擎采用的是 B+ 树的数据结构来存储索引的。</p><p>非叶子节点存储指针、叶子节点存储数据、叶子节点是一个双向循环链表。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">B 树和 B+ 树有什么区别？</p><blockquote><p>Tips：B+Tree 是在 BTree 基础上的一种优化。</p><p>B 树与 B+ 树的对比：</p><ol><li>磁盘读写代价 B+ 树更低。</li><li>查询效率 B+ 树更加稳定。</li><li>B+ 树便于扫库和区间查询。</li></ol></blockquote></div><div class="hint-container info"><p class="hint-container-title">什么是聚集索引和二级索引？</p><blockquote><p>聚集索引：将数据存储与索引放到了一块，索引结构的叶子节点保存了整行的数据（有且只有一个）。</p><p>二级索引：将数据与索引分开存储，索引结构的叶子节点关联的是对应行的主键值（可以有多个）。</p><p>聚集索引选取规则：</p><ol><li>如果存在主键，则主键索引就是聚集索引。</li><li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li><li>如果表没有主键，也没有合适的唯一（UNIQUE）索引，则 InnoDB 存储引擎会自动生成一个 <code>rowid</code> 作为隐藏的聚集索引。</li></ol><p><img src="'+r+'" alt="聚集索引和二级索引" loading="lazy"></p></blockquote></div><div class="hint-container info"><p class="hint-container-title">什么是回表查询？</p><blockquote><p>通过二级索引找到对应的主键值，然后到聚集索引中查找整行数据，这个过程就是回表查询。</p><p><img src="'+d+`" alt="回表查询" loading="lazy"></p></blockquote></div><div class="hint-container info"><p class="hint-container-title">什么是覆盖索引？</p><blockquote><p>覆盖索引是指：查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到（不需要回表查询）。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">MySQL 超大分页怎么处理？</p><blockquote><p>可以通过覆盖索引加子查询的方式来解决。</p><div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_sku t<span class="token punctuation">,</span>  <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> tb_sku <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">9000000</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> a <span class="token keyword">where</span> t<span class="token punctuation">.</span>id <span class="token operator">=</span> a<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre></div><p>在数据量比较大时，如果进行 <code>limit</code> 分页查询，在查询时，越往后，分页查询效率越低。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">索引创建原则有哪些？</p><blockquote><p>主键索引。</p><p>唯一索引。</p><p>复合索引（根据业务情况创建的索引）。</p><p><strong>索引创建的规则如下</strong>：</p><ol><li>针对于数据量较大，且查询比较频繁的表建立索引（一般单表超过10万数据（增加用户体验））- <mark>重点</mark>。</li><li>针对于常作为查询条件（<code>where</code>）、排序（<code>order by</code>）、分组（<code>group by</code>）操作的字段建立索引 - <mark>重点</mark>。</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率 - <mark>重点</mark>。</li><li>如果索引列不能存储 <code>NULL</code> 值，请在创建表时使用 <code>NOT NULL</code> 约束它。当优化器知道每列是否包含 <code>NULL</code> 值时，它可以更好地确定哪个索引最有效地用于查询。</li></ol><p>注意：要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率 - <mark>重点</mark>。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">什么情况下索引会失效？</p><blockquote><p>首先通过 <code>explain</code> 命令查看 SQL 语句执行计划。</p><ol><li>违反最左前缀法则（联合索引的情况下）： <ul><li>指的是查询从索引的最左前列开始，并且不跳过索引中的列（索引生效）。</li><li>违反最左前缀法则（索引失效）。</li><li>如果符合最左前缀法则，但是出现跳跃某一列，则只有最左列的索引生效（最左列的部分生效）。</li></ul></li><li>如果在添加了索引的字段上进行了运算操作则索引会失效。</li><li>字符串不加单引号会造成索引失效（只要发生了类型转换就会导致索引失效）。</li><li>模糊查询的时候，如果 % 号在前面也会导致索引失效。</li></ol></blockquote></div><div class="hint-container info"><p class="hint-container-title">谈一谈你对 SQL 的优化的经验。</p><blockquote><p>表的设计优化（参考阿里开发手册《嵩山版》）：</p><ul><li>比如设置合适的数值（<code>tinyint</code>、<code>int</code>、<code>bigint</code>）- 要根据实际情况选择。</li><li>比如设置合适的字符串类型（<code>char</code>、<code>varchar</code>）<code>char</code> 定长效率高、<code>varchar</code> 可变长度，效率稍低。</li></ul><p>索引优化（参考索引创建原则和索引失效的情况）。</p><p>SQL 语句优化：</p><ul><li>SELECT 语句务必指明字段名称（避免直接使用 <code>select *</code>）。</li><li>SQL 语句要避免造成索引失效的写法。</li><li>尽量用 <code>union all</code> 代替 <code>union</code>（<code>union</code> 会多一次过滤 - 效率低）。</li><li>避免在 <code>where</code> 子句中对字段进行表达式操作。</li><li>Join 优化能用 <code>inner join</code> 就不用 <code>left join</code>、<code>right join</code>，如必须使用，一定要以小表为驱动，内连接会对两个表进行优化，优先把小表放到外边，把大表放到里边（<code>left join</code> 或 <code>right join</code> 不会重新调整顺序）。</li></ul><p>集群优化（主从复制、读写分离）：</p><ul><li>如果数据库的使用场景读的操作比较多的时候，为了避免写的操作所造成的性能影响，可以采用读写分离的架构。</li><li>读写分离解决的是，数据库的写入，影响了查询的效率。</li></ul><p>分库分表。</p></blockquote></div><h3 id="其它" tabindex="-1"><a class="header-anchor" href="#其它"><span>其它</span></a></h3><div class="hint-container info"><p class="hint-container-title">。</p></div><div class="hint-container info"><p class="hint-container-title">。</p></div><div class="hint-container info"><p class="hint-container-title">。</p></div><div class="hint-container info"><p class="hint-container-title">。</p></div><div class="hint-container info"><p class="hint-container-title">。</p></div><div class="hint-container info"><p class="hint-container-title">。</p></div><div class="hint-container info"><p class="hint-container-title">。</p></div><div class="hint-container info"><p class="hint-container-title">。</p></div><div class="hint-container info"><p class="hint-container-title">。</p></div><div class="hint-container info"><p class="hint-container-title">。</p></div><div class="hint-container info"><p class="hint-container-title">。</p></div>`,28);function k(y,v){return e(),n("div",null,[u,o(" more "),m])}const f=t(h,[["render",k],["__file","index.html.vue"]]),b=JSON.parse('{"path":"/audition/mysql/","title":"MySQL","lang":"zh-CN","frontmatter":{"title":"MySQL","icon":"MYSQL8","category":"面试题","tag":"面试题","timeline":true,"star":true,"description":" 注 此处是一些 MySQL 高频面试题（持续更新中...）。 面试题汇总 优化 DQL 语句的执行顺序？ DQL语句的执行顺序 在 MySQL 中如何定位慢查询？ 原因： 聚合查询。 多表查询。 表数据量过大查询。 深度分页查询。 表现：页面加载过慢、接口压测响应时间过长（例如：超过 1s）。 定位： 开源工具： 调试工具：Arthas。 运维工具：...","head":[["meta",{"property":"og:url","content":"https://SuperChenWenjing.github.io/audition/mysql/"}],["meta",{"property":"og:site_name","content":"陈文景"}],["meta",{"property":"og:title","content":"MySQL"}],["meta",{"property":"og:description","content":" 注 此处是一些 MySQL 高频面试题（持续更新中...）。 面试题汇总 优化 DQL 语句的执行顺序？ DQL语句的执行顺序 在 MySQL 中如何定位慢查询？ 原因： 聚合查询。 多表查询。 表数据量过大查询。 深度分页查询。 表现：页面加载过慢、接口压测响应时间过长（例如：超过 1s）。 定位： 开源工具： 调试工具：Arthas。 运维工具：..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-04T03:13:42.000Z"}],["meta",{"property":"article:author","content":"陈文景"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:modified_time","content":"2024-05-04T03:13:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-04T03:13:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"陈文景\\",\\"email\\":\\"2646530197@qq.com\\",\\"url\\":\\"https://superchenwenjing.github.io\\"}]}"]],"date":"2024-03-08T16:03:07.000Z"},"headers":[{"level":2,"title":"面试题汇总","slug":"面试题汇总","link":"#面试题汇总","children":[{"level":3,"title":"优化","slug":"优化","link":"#优化","children":[]},{"level":3,"title":"其它","slug":"其它","link":"#其它","children":[]}]}],"git":{"createdTime":1709913787000,"updatedTime":1714792422000,"contributors":[{"name":"陈文景","email":"2646530197@qq.com","commits":3}]},"readingTime":{"minutes":7.03,"words":2108},"filePathRelative":"audition/mysql/README.md","localizedDate":"2024年3月8日","excerpt":"<div class=\\"hint-container note\\">\\n<p class=\\"hint-container-title\\">注</p>\\n<p>此处是一些 MySQL 高频面试题（持续更新中...）。</p>\\n</div>\\n","autoDesc":true}');export{f as comp,b as data};
