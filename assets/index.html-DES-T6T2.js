import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as i,c as e,b as l,d as o,f as a}from"./app-BrScejxt.js";const r={},n=o("p",null,"此处是一些 Java 集合的高频面试题（持续更新中...）。",-1),c=a('<h2 id="集合" tabindex="-1"><a class="header-anchor" href="#集合"><span>集合</span></a></h2><div class="hint-container tip"><p class="hint-container-title">ArrayList 扩容规则？</p><ol><li><code>ArrayList()</code> 会使用长度为零的数组。</li><li><code>ArrayList(int initialCapacity)</code> 会使用指定容量的数组。</li><li><code>ArrayList(Collection&lt;? extends E&gt; c)</code> 会使用 <code>c</code> 的大小作为数组容量。</li><li><code>add(Object o)</code>： <ol><li>首次扩容为 10。</li><li>再次扩容则为上次容量的 1.5 倍。</li></ol></li><li><code>addAll(Collection c)</code>： <ol><li>没有元素时：扩容为 <code>Math.max(10, 实际元素个数)</code>。</li><li>有元素时为：扩容为 <code>Math.max(原容量 1.5 倍, 实际元素个数)</code>。</li></ol></li></ol></div><div class="hint-container info"><p class="hint-container-title">Iterator 的 Fail-Fast 与 Fail-Safe？</p><ul><li><p><code>ArrayList</code> 是 <code>fail-fast</code> 的典型代表，遍历的同时不能修改，尽快失败。</p></li><li><p><code>CopyOnWriteArrayList</code> 是 <code>fail-safe</code> 的典型代表，遍历的同时可以修改，原理是读写分离。</p></li></ul></div><div class="hint-container tip"><p class="hint-container-title">LinkedList 对比 ArrayList 的区别？</p><p><strong>LinkedList</strong>：</p><ol><li>基于双向链表，无需连续内存。</li><li>随机访问慢（要沿着链表遍历）。</li><li>头尾插入删除性能高。</li><li>占用内存多。</li></ol><p><strong>ArrayList</strong></p><ol><li>基于数组，需要连续内存。</li><li>随机访问快（指根据下标访问）。</li><li>尾部插入、删除性能可以，其它部分插入、删除都会移动数据，因此性能会低。</li><li>可以利用 CPU 缓存，局部性原理。</li></ol></div><div class="hint-container warning"><p class="hint-container-title">HashMap 的基本数据结构？</p><p><strong>基本数据结构</strong>：</p><ul><li>JDK1.7：数组 + 链表。</li><li>JDK1.8：数组 + （链表 | 红黑树）。</li></ul><p><strong>树化与退化</strong>：</p><ul><li><p>树化的意义：</p><ul><li><p>红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况，是保底策略。</p></li><li><p>hash 表的查找，更新的时间复杂度是 $O(1)$，而红黑树的查找，更新的时间复杂度是 $O(log_2⁡n )$，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表。</p></li><li><p>hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小。</p></li></ul></li><li><p>树化规则：</p><ul><li>当链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 &gt;=64，才会进行树化。</li></ul></li><li><p>退化规则：</p><ul><li>情况1：在扩容时如果拆分树时，树元素个数 &lt;= 6 则会退化链表。</li><li>情况2：remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表。</li></ul></li></ul></div>',5);function s(p,d){return i(),e("div",null,[n,l(" more "),c])}const u=t(r,[["render",s],["__file","index.html.vue"]]),y=JSON.parse('{"path":"/audition/java/collection/","title":"集合","lang":"zh-CN","frontmatter":{"title":"集合","icon":"Code","category":"面试题","tag":"面试题","timeline":true,"star":true,"description":"此处是一些 Java 集合的高频面试题（持续更新中...）。 集合 ArrayList 扩容规则？ ArrayList() 会使用长度为零的数组。 ArrayList(int initialCapacity) 会使用指定容量的数组。 ArrayList(Collection<? extends E> c) 会使用 c 的大小作为数组容量。 add(Ob...","head":[["meta",{"property":"og:url","content":"https://SuperChenWenjing.github.io/audition/java/collection/"}],["meta",{"property":"og:site_name","content":"陈文景"}],["meta",{"property":"og:title","content":"集合"}],["meta",{"property":"og:description","content":"此处是一些 Java 集合的高频面试题（持续更新中...）。 集合 ArrayList 扩容规则？ ArrayList() 会使用长度为零的数组。 ArrayList(int initialCapacity) 会使用指定容量的数组。 ArrayList(Collection<? extends E> c) 会使用 c 的大小作为数组容量。 add(Ob..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-03T01:51:35.000Z"}],["meta",{"property":"article:author","content":"陈文景"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:modified_time","content":"2024-05-03T01:51:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"集合\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-03T01:51:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"陈文景\\",\\"email\\":\\"2646530197@qq.com\\",\\"url\\":\\"https://superchenwenjing.github.io\\"}]}"]],"date":"2024-03-08T16:03:07.000Z"},"headers":[{"level":2,"title":"集合","slug":"集合","link":"#集合","children":[]}],"git":{"createdTime":1709913787000,"updatedTime":1714701095000,"contributors":[{"name":"陈文景","email":"2646530197@qq.com","commits":2}]},"readingTime":{"minutes":2.09,"words":628},"filePathRelative":"audition/java/collection/README.md","localizedDate":"2024年3月8日","excerpt":"<p>此处是一些 Java 集合的高频面试题（持续更新中...）。</p>\\n","autoDesc":true}');export{u as comp,y as data};
