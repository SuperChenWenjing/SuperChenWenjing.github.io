import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as i,c as t,b as o,d as e,f as n}from"./app-CiSWrg8b.js";const r="/assets/操作系统层面五种线程状态-B2W_4Qal.jpg",s="/assets/JavaAPI层面的六种状态-DT5QDtTH.png",a={},c=e("p",null,"此处是一些 Java 并发编程的高频面试题（持续更新中...）。",-1),d=n('<h2 id="线程状态" tabindex="-1"><a class="header-anchor" href="#线程状态"><span>线程状态</span></a></h2><div class="hint-container tip"><p class="hint-container-title">操作系统层面五种线程状态。</p><p><img src="'+r+'" alt="操作系统层面五种线程状态" loading="lazy"></p></div><div class="hint-container tip"><p class="hint-container-title">JavaAPI 层面的六种状态。</p><p>这是从 Java API 层面来描述的六种状态（在 <code>Thread.State</code> 枚举类中定义）。</p><p><img src="'+s+'" alt="JavaAPI层面的六种状态" loading="lazy"></p></div><div class="hint-container tip"><p class="hint-container-title">详细的文字描述。</p><ul><li><strong>新建</strong>： <ul><li>当一个线程对象被创建，但还未调用 <code>start</code> 方法时处于<strong>新建</strong>状态。</li><li>此时未与操作系统底层线程关联。</li></ul></li><li><strong>可运行</strong>： <ul><li>调用了 <code>start</code> 方法，就会由<strong>新建</strong>进入<strong>可运行</strong>。</li><li>此时与底层线程关联，由操作系统调度执行。</li></ul></li><li><strong>终结</strong>： <ul><li>线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong>。</li><li>此时会取消与底层线程关联。</li></ul></li><li><strong>阻塞</strong>： <ul><li>当获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，此时不占用 CPU 时间。</li><li>当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态。</li></ul></li><li><strong>等待</strong>： <ul><li>当获取锁成功后，但由于条件不满足，调用了 <code>wait()</code> 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合<strong>等待</strong>，同样不占用 CPU 时间。</li><li>当其它持锁线程调用 <code>notify()</code> 或 <code>notifyAll()</code> 方法，会按照一定规则唤醒等待集合中的<strong>等待</strong>线程，恢复为<strong>可运行</strong>状态。</li></ul></li><li><strong>有时限等待</strong>： <ul><li>当获取锁成功后，但由于条件不满足，调用了 <code>wait(long)</code> 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合进行<strong>有时限等待</strong>，同样不占用 CPU 时间。</li><li>当其它持锁线程调用 <code>notify()</code> 或 <code>notifyAll()</code> 方法，会按照一定规则唤醒等待集合中的<strong>有时限等待</strong>线程，恢复为<strong>可运行</strong>状态，并重新去竞争锁。</li><li>如果等待超时，也会从<strong>有时限等待</strong>状态恢复为<strong>可运行</strong>状态，并重新去竞争锁。</li><li>还有一种情况是调用 <code>sleep(long)</code> 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，但与 Monitor 无关，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态。</li></ul></li></ul><blockquote><p>其它情况（只需了解即可）:</p><ul><li>可以用 <code>interrupt()</code> 方法打断<strong>等待</strong>、<strong>有时限等待</strong>的线程，让它们恢复为<strong>可运行</strong>状态。</li><li><code>park</code>、<code>unpark</code> 等方法也可以让线程等待和唤醒。</li></ul></blockquote></div><h2 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池"><span>线程池</span></a></h2><div class="hint-container tip"><p class="hint-container-title">线程池的 7 大核心参数。</p><ol><li>corePoolSize 核心线程数目 - 池中会保留的最多线程数。</li><li>maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目。</li><li>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放。</li><li>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等。</li><li>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务。</li><li>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等。</li><li>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略： <ol><li>抛异常 java.util.concurrent.ThreadPoolExecutor.AbortPolicy。</li><li>由调用者执行任务 java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy。</li><li>丢弃任务 java.util.concurrent.ThreadPoolExecutor.DiscardPolicy。</li><li>丢弃最早排队任务 java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy。</li></ol></li></ol></div><h2 id="wait-vs-sleep" tabindex="-1"><a class="header-anchor" href="#wait-vs-sleep"><span>wait vs sleep</span></a></h2><div class="hint-container tip"><p class="hint-container-title">wait 和 sleep 方法的区别。</p><p>一个共同点、三个不同点：</p><p><strong>共同点</strong>：</p><ul><li><code>wait()</code> 、<code>wait(long)</code> 和 <code>sleep(long)</code> 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态。</li></ul><p><strong>不同点</strong>：</p><ul><li><p>方法归属不同：</p><ul><li><code>sleep(long)</code> 是 Thread 类的静态方法。</li><li>而 <code>wait()</code> 、<code>wait(long)</code> 都是 Object 类的成员方法（每个对象都有）。</li></ul></li><li><p>醒来时机不同：</p><ul><li>执行 <code>sleep(long)</code> 和 <code>wait(long)</code> 的线程都会在等待相应毫秒后醒来。</li><li><code>wait(long)</code> 和 <code>wait()</code> 还可以被 <code>notify()</code> 唤醒，而 <code>wait()</code> 如果不唤醒就一直等下去。</li><li>它们都可以被打断唤醒。</li></ul></li><li><p>锁特性不同（重点）：</p><ul><li><code>wait()</code> 方法的调用必须先获取 <code>synchronized</code> 对象的锁，而 <code>sleep()</code> 则无此限制。</li><li><code>wait()</code> 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 CPU，但你们还可以用）。</li><li>而 <code>sleep()</code> 如果在 <code>synchronized</code> 代码块中执行，并不会释放对象锁（我放弃 CPU，你们也用不了）。</li></ul></li></ul></div><h2 id="lock-vs-synchronized" tabindex="-1"><a class="header-anchor" href="#lock-vs-synchronized"><span>lock vs synchronized</span></a></h2><div class="hint-container tip"><p class="hint-container-title">lock 和 synchronized 锁的区别。</p><p><strong>三个层面</strong>：</p><p>不同点：</p><ul><li>语法层面： <ul><li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现。</li><li>Lock 是接口，源码由 jdk 提供，用 java 语言实现。</li><li>使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁。</li></ul></li><li>功能层面： <ul><li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能。</li><li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量。</li><li>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock。</li></ul></li><li>性能层面： <ul><li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖。</li><li>在竞争激烈时，Lock 的实现通常会提供更好的性能。</li></ul></li></ul><p><strong>公平锁</strong>：</p><ul><li>公平锁的公平体现： <ul><li><strong>已经处在阻塞队列</strong>中的线程（不考虑超时）始终都是公平的，先进先出。</li><li>公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，如果队列不为空，则老实到队尾等待。</li><li>非公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，与队列头唤醒的线程去竞争，谁抢到算谁的。</li></ul></li><li>公平锁会降低吞吐量，一般不用。</li></ul><p><strong>条件变量</strong>：</p><ul><li>ReentrantLock 中的条件变量功能类似于普通 synchronized 的 wait，notify，用在当线程获得锁后，发现条件不满足时，临时等待的链表结构。</li><li>与 synchronized 的等待集合不同之处在于，ReentrantLock 中的条件变量可以有多个，可以实现更精细的等待、唤醒控制。</li></ul></div><h2 id="volatile" tabindex="-1"><a class="header-anchor" href="#volatile"><span>volatile</span></a></h2><div class="hint-container tip"><p class="hint-container-title">volatile 关键字的作用。</p><p><strong>要求</strong>：</p><ul><li>掌握线程安全要考虑的三个问题。</li><li>掌握 volatile 能解决哪些问题。</li></ul><p><strong>原子性</strong>：</p><ul><li>起因：多线程下，不同线程的<strong>指令发生了交错</strong>导致的共享变量的读写混乱。</li><li>解决：用悲观锁或乐观锁解决，volatile 并不能解决原子性。</li></ul><p><strong>可见性</strong>：</p><ul><li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致的对共享变量所做的修改另外的线程看不到。</li><li>解决：用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见。</li></ul><p><strong>有序性</strong>：</p><ul><li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致指令的实际执行顺序与编写顺序不一致。</li><li>解决：用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果。</li><li>注意： <ul><li><strong>volatile 变量写</strong>加的屏障是阻止上方其它写操作越过屏障排到 <strong>volatile 变量写</strong>之下。</li><li><strong>volatile 变量读</strong>加的屏障是阻止下方其它读操作越过屏障排到 <strong>volatile 变量读</strong>之上。</li><li>volatile 读写加入的屏障只能防止同一线程内的指令重排。</li></ul></li></ul></div><h2 id="悲观锁-vs-乐观锁" tabindex="-1"><a class="header-anchor" href="#悲观锁-vs-乐观锁"><span>悲观锁 vs 乐观锁</span></a></h2><div class="hint-container tip"><p class="hint-container-title">掌握悲观锁和乐观锁的区别。</p><p><strong>对比悲观锁与乐观锁</strong>：</p><ul><li><p>悲观锁的代表是 synchronized 和 Lock 锁。</p><ul><li>其核心思想是【线程只有占有了锁，才能去操作共享变量，每次只有一个线程占锁成功，获取锁失败的线程，都得停下来等待】。</li><li>线程从运行到阻塞、再从阻塞到唤醒，涉及线程上下文切换，如果频繁发生，影响性能。</li><li>实际上，线程在获取 synchronized 和 Lock 锁时，如果锁已被占用，都会做几次重试操作，减少阻塞的机会。</li></ul></li><li><p>乐观锁的代表是 AtomicInteger，使用 cas 来保证原子性。</p><ul><li>其核心思想是【无需加锁，每次只有一个线程能成功修改共享变量，其它失败的线程不需要停止，不断重试直至成功】。</li><li>由于线程一直运行，不需要阻塞，因此不涉及线程上下文切换。</li><li>它需要多核 cpu 支持，且线程数不应超过 cpu 核数。</li></ul></li></ul></div>',14);function p(g,u){return i(),t("div",null,[c,o(" more "),d])}const m=l(a,[["render",p],["__file","index.html.vue"]]),y=JSON.parse('{"path":"/audition/java/concurrent/","title":"并发编程","lang":"zh-CN","frontmatter":{"title":"并发编程","icon":"Code","category":"面试题","tag":"面试题","timeline":true,"star":true,"description":"此处是一些 Java 并发编程的高频面试题（持续更新中...）。 线程状态 操作系统层面五种线程状态。 操作系统层面五种线程状态 JavaAPI 层面的六种状态。 这是从 Java API 层面来描述的六种状态（在 Thread.State 枚举类中定义）。 JavaAPI层面的六种状态 详细的文字描述。 新建： 当一个线程对象被创建，但还未调用 st...","head":[["meta",{"property":"og:url","content":"https://SuperChenWenjing.github.io/audition/java/concurrent/"}],["meta",{"property":"og:site_name","content":"陈文景"}],["meta",{"property":"og:title","content":"并发编程"}],["meta",{"property":"og:description","content":"此处是一些 Java 并发编程的高频面试题（持续更新中...）。 线程状态 操作系统层面五种线程状态。 操作系统层面五种线程状态 JavaAPI 层面的六种状态。 这是从 Java API 层面来描述的六种状态（在 Thread.State 枚举类中定义）。 JavaAPI层面的六种状态 详细的文字描述。 新建： 当一个线程对象被创建，但还未调用 st..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-03T06:56:15.000Z"}],["meta",{"property":"article:author","content":"陈文景"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:modified_time","content":"2024-05-03T06:56:15.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"并发编程\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-03T06:56:15.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"陈文景\\",\\"email\\":\\"2646530197@qq.com\\",\\"url\\":\\"https://superchenwenjing.github.io\\"}]}"]],"date":"2024-03-08T16:03:07.000Z"},"headers":[{"level":2,"title":"线程状态","slug":"线程状态","link":"#线程状态","children":[]},{"level":2,"title":"线程池","slug":"线程池","link":"#线程池","children":[]},{"level":2,"title":"wait vs sleep","slug":"wait-vs-sleep","link":"#wait-vs-sleep","children":[]},{"level":2,"title":"lock vs synchronized","slug":"lock-vs-synchronized","link":"#lock-vs-synchronized","children":[]},{"level":2,"title":"volatile","slug":"volatile","link":"#volatile","children":[]},{"level":2,"title":"悲观锁 vs 乐观锁","slug":"悲观锁-vs-乐观锁","link":"#悲观锁-vs-乐观锁","children":[]}],"git":{"createdTime":1709913787000,"updatedTime":1714719375000,"contributors":[{"name":"陈文景","email":"2646530197@qq.com","commits":3}]},"readingTime":{"minutes":7.39,"words":2217},"filePathRelative":"audition/java/concurrent/README.md","localizedDate":"2024年3月8日","excerpt":"<p>此处是一些 Java 并发编程的高频面试题（持续更新中...）。</p>\\n","autoDesc":true}');export{m as comp,y as data};
