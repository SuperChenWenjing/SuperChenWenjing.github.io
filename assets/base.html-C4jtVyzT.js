import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as o,f as a}from"./app-CZurSp36.js";const d={},c=a('<h2 id="关于继承" tabindex="-1"><a class="header-anchor" href="#关于继承"><span>关于继承</span></a></h2><p><strong>继承的特点：</strong></p><ul><li>子类可以继承父类的属性和行为，但是子类不能继承父类的构造器。</li><li><strong>Java是单继承模式：一个类只能继承一个直接父类。</strong></li><li>Java不支持多继承、但是支持多层继承。</li><li>Java中所有的类都是Object类的子类。</li></ul><p><strong>引发的思考：</strong></p><ul><li><p>子类是否可以继承父类的构造器？</p><p>不可以的，子类有自己的构造器，父类构造器用于初始化父类对象。</p></li><li><p>子类是否可以继承父类的私有成员？</p><p>可以的，只是不能直接访问。</p><p>子类虽然会继承父类的私有（private）的成员变量，但是子类不能直接对继承的私有成员变量进行访问，可以通过继承的 <code>get/set</code>方法进行访问。</p></li><li><p>子类是否可以继承父类的静态成员？</p><p>有争议的知识点。</p><p>子类可以直接使用父类的静态成员（共享）。</p><p>但个人认为：子类不能继承父类的静态成员（共享并非继承）。</p></li></ul><h2 id="权限修饰符" tabindex="-1"><a class="header-anchor" href="#权限修饰符"><span>权限修饰符</span></a></h2><div class="hint-container tip"><p class="hint-container-title">权限修饰符（访问控制修饰符）是什么？</p><p>用于限制类中的成员（成员变量、成员方法、构造器、代码块、...）能够被访问的范围。</p></div><p><strong>权限修饰符（访问控制修饰符）：</strong></p><table><thead><tr><th>修饰符</th><th>同一个类中</th><th>同一个包中的其它类</th><th>不同包下的子类</th><th>不同包下的无关类</th></tr></thead><tbody><tr><td><code>private</code></td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td><code>缺省</code></td><td>✅</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td><code>protected</code></td><td>✅</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td><code>public</code></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr></tbody></table><blockquote><p>控制范围：<code>private</code> &lt; <code>缺省</code> &lt; <code>protected</code> &lt; <code>public</code>。</p></blockquote><div class="hint-container warning"><p class="hint-container-title">注意</p><p>构造器的修饰符只能是权限修饰符，不能被其他任何修饰。</p><p>例如：不能被 <code>static</code>、<code>final</code>、<code>synchronized</code>、<code>abstract</code>、<code>native</code> 修饰，不能有 <code>return</code> 语句返回值。</p><p>对于 <code>static final</code> 的成员变量，习惯上使用 <code>public</code> 修饰（常量）。</p></div>',11),i=[c];function r(n,p){return e(),o("div",null,i)}const h=t(d,[["render",r],["__file","base.html.vue"]]),m=JSON.parse('{"path":"/notes/java/oop/base.html","title":"基础","lang":"zh-CN","frontmatter":{"title":"基础","icon":"Code","category":"Java","timeline":true,"star":true,"description":"关于继承 继承的特点： 子类可以继承父类的属性和行为，但是子类不能继承父类的构造器。 Java是单继承模式：一个类只能继承一个直接父类。 Java不支持多继承、但是支持多层继承。 Java中所有的类都是Object类的子类。 引发的思考： 子类是否可以继承父类的构造器？ 不可以的，子类有自己的构造器，父类构造器用于初始化父类对象。 子类是否可以继承父类...","head":[["meta",{"property":"og:url","content":"https://SuperChenWenjing.github.io/notes/java/oop/base.html"}],["meta",{"property":"og:site_name","content":"陈文景"}],["meta",{"property":"og:title","content":"基础"}],["meta",{"property":"og:description","content":"关于继承 继承的特点： 子类可以继承父类的属性和行为，但是子类不能继承父类的构造器。 Java是单继承模式：一个类只能继承一个直接父类。 Java不支持多继承、但是支持多层继承。 Java中所有的类都是Object类的子类。 引发的思考： 子类是否可以继承父类的构造器？ 不可以的，子类有自己的构造器，父类构造器用于初始化父类对象。 子类是否可以继承父类..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-07T03:37:40.000Z"}],["meta",{"property":"article:author","content":"陈文景"}],["meta",{"property":"article:modified_time","content":"2024-04-07T03:37:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"基础\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-07T03:37:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"陈文景\\",\\"email\\":\\"2646530197@qq.com\\",\\"url\\":\\"https://superchenwenjing.github.io\\"}]}"]],"date":"2024-04-06T07:26:51.000Z"},"headers":[{"level":2,"title":"关于继承","slug":"关于继承","link":"#关于继承","children":[]},{"level":2,"title":"权限修饰符","slug":"权限修饰符","link":"#权限修饰符","children":[]}],"git":{"createdTime":1712388411000,"updatedTime":1712461060000,"contributors":[{"name":"陈文景","email":"2646530197@qq.com","commits":2}]},"readingTime":{"minutes":1.55,"words":465},"filePathRelative":"notes/java/oop/base.md","localizedDate":"2024年4月6日","excerpt":"","autoDesc":true}');export{h as comp,m as data};
