import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as s,c,b as d,d as t,a as e,w as a,f as r,e as l}from"./app-BsynsZlL.js";const u="/assets/Java集合体系-Badb61TL.png",h="/assets/HashMap的put流程-B48043qs.png",p={},v=t("p",null,"此处是一些 Java 高频面试题（持续更新中...）。",-1),m=t("h2",{id:"目录",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#目录"},[t("span",null,"目录")])],-1),f=t("h3",{id:"基础",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#基础"},[t("span",null,"基础")])],-1),_=t("h3",{id:"集合",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#集合"},[t("span",null,"集合")])],-1),j=t("h3",{id:"并发编程",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#并发编程"},[t("span",null,"并发编程")])],-1),g=t("h3",{id:"io",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#io"},[t("span",null,"IO")])],-1),k=t("h3",{id:"jvm",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#jvm"},[t("span",null,"JVM")])],-1),J=t("h3",{id:"新特性",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#新特性"},[t("span",null,"新特性")])],-1),b=r('<h2 id="面试题汇总" tabindex="-1"><a class="header-anchor" href="#面试题汇总"><span>面试题汇总</span></a></h2><h3 id="常见集合面试题" tabindex="-1"><a class="header-anchor" href="#常见集合面试题"><span>常见集合面试题</span></a></h3><div class="hint-container info"><p class="hint-container-title">Java 集合体系。</p><blockquote><p><img src="'+u+'" alt="Java集合体系" loading="lazy"></p></blockquote></div><div class="hint-container info"><p class="hint-container-title">ArrayList 底层的数据结构和扩容的机制。</p><blockquote><p>每次扩容是原来的 1.5 倍。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">如何实现数组和 List 之间的转换？</p><blockquote><p>数组转 List：<code>Arrays.asList(T... a)</code>。</p><ul><li>如果修改了原数组的内容，会影响转换后的 List。</li><li>使用的是 Arrays 类内部的一个 ArrayList 来构建的集合。</li></ul><p>List 转数组：<code>List.toArray()</code> - 不影响原 List。</p><ul><li>如果修改的原 List 的内容，不会影响转换后的数组。</li><li>底层进行了数组的拷贝。</li></ul></blockquote></div><div class="hint-container info"><p class="hint-container-title">ArrayList 和 LinkedList 的区别是什么？</p><blockquote><p><strong>从几个方面回答</strong>：</p><ul><li>底层数据结构：动态数组、双向链表的不同特点。</li><li>操作效率。</li><li>占用的内存空间（数组需要连续的内存空间、链表不需要）。</li><li>线程是否安全：ArrayList 和 LinkedList 都不是线程安全的类。</li></ul></blockquote></div><div class="hint-container info"><p class="hint-container-title">HashMap 相关面试题。</p><blockquote><p>底层数据结构：</p><ul><li>JDK 1.7：数组 + 链表（采用的是拉链法）。</li><li>JDK 1.8：数组 + 链表 + 红黑树。</li></ul><p>名词：哈希碰撞、拉链法、头插法（JDK 1.7）、扰动算法、加载因子（0.75）。</p><p>树化：链表的长度大于 8 且数组的长度大于 64 则链表转化为红黑树（默认数组长度为 16）。</p><p>退化：红黑树拆分成的树的节点数小于等于临界值 6 时则退化为链表。</p><p><strong>HashMap 的 <code>put</code> 流程</strong>：</p><p><img src="'+h+'" alt="HashMap 的put流程" loading="lazy"></p><p><strong>文字描述 <code>put</code> 的流程</strong>：</p><ol><li>判断键值对数组 <code>table</code> 是否为空或为 <code>null</code>，否则执行 <code>resize()</code> 方法进行扩容（初始化）。</li><li>根据键值 <code>key</code> 计算 <code>hash</code> 值得到数组索引。</li><li>判断 <code>table[i]==null</code>，条件成立，直接新建节点添加。</li><li>如果 <code>table[i]==null</code>，不成立： <ol><li>判断 <code>table[i]</code> 的首个元素是否和 <code>key</code> 一样，如果相同直接覆盖 <code>value</code>。</li><li>判断 <code>table[i]</code> 是否为 <code>treeNode</code>，即 <code>table[i]</code> 是否是红黑树，如果是红黑树，则直接在树中插入键值对。</li><li>遍历 <code>table[i]</code>，链表的尾部插入数据，然后判断链表长度是否大于 8，大于 8 的话把链表转换为红黑树，在红黑树中执行插入操作，遍历过程中若发现 <code>key</code> 已经存在直接覆盖 <code>value</code>。</li></ol></li><li>插入成功后，判断实际存在的键值对数量 <code>size</code> 是否超多了最大容量 <code>threshold</code>（数组长度 * 0.75），如果超过，进行扩容。</li></ol><p><strong>HashMap 的寻址算法</strong>：</p></blockquote></div><h3 id="多线程面试题" tabindex="-1"><a class="header-anchor" href="#多线程面试题"><span>多线程面试题</span></a></h3><div class="hint-container info"><p class="hint-container-title">。</p></div><div class="hint-container info"><p class="hint-container-title">。</p></div><div class="hint-container info"><p class="hint-container-title">。</p></div><div class="hint-container info"><p class="hint-container-title">。</p></div><div class="hint-container info"><p class="hint-container-title">。</p></div><div class="hint-container info"><p class="hint-container-title">。</p></div><div class="hint-container info"><p class="hint-container-title">。</p></div><div class="hint-container info"><p class="hint-container-title">。</p></div><div class="hint-container info"><p class="hint-container-title">。</p></div><div class="hint-container info"><p class="hint-container-title">。</p></div><div class="hint-container info"><p class="hint-container-title">。</p></div><div class="hint-container info"><p class="hint-container-title">。</p></div>',20);function y(L,D){const i=o("RouteLink");return s(),c("div",null,[v,d(" more "),m,f,t("ul",null,[t("li",null,[e(i,{to:"/audition/java/core/"},{default:a(()=>[l("基础")]),_:1})])]),_,t("ul",null,[t("li",null,[e(i,{to:"/audition/java/collection/"},{default:a(()=>[l("集合")]),_:1})])]),j,t("ul",null,[t("li",null,[e(i,{to:"/audition/java/concurrent/"},{default:a(()=>[l("并发编程")]),_:1})])]),g,t("ul",null,[t("li",null,[e(i,{to:"/audition/java/io/"},{default:a(()=>[l("IO")]),_:1})])]),k,t("ul",null,[t("li",null,[e(i,{to:"/audition/java/jvm/"},{default:a(()=>[l("JVM")]),_:1})])]),J,t("ul",null,[t("li",null,[e(i,{to:"/audition/java/new/"},{default:a(()=>[l("新特性")]),_:1}),t("ul",null,[t("li",null,[e(i,{to:"/audition/java/new/jdk8.html"},{default:a(()=>[l("JDK8")]),_:1})]),t("li",null,[e(i,{to:"/audition/java/new/jdk9.html"},{default:a(()=>[l("JDK9")]),_:1})]),t("li",null,[e(i,{to:"/audition/java/new/jdk10.html"},{default:a(()=>[l("JDK10")]),_:1})]),t("li",null,[e(i,{to:"/audition/java/new/jdk11.html"},{default:a(()=>[l("JDK11")]),_:1})]),t("li",null,[e(i,{to:"/audition/java/new/jdk12.html"},{default:a(()=>[l("JDK12")]),_:1})]),t("li",null,[e(i,{to:"/audition/java/new/jdk13.html"},{default:a(()=>[l("JDK13")]),_:1})]),t("li",null,[e(i,{to:"/audition/java/new/jdk14.html"},{default:a(()=>[l("JDK14")]),_:1})]),t("li",null,[e(i,{to:"/audition/java/new/jdk15.html"},{default:a(()=>[l("JDK15")]),_:1})]),t("li",null,[e(i,{to:"/audition/java/new/jdk16.html"},{default:a(()=>[l("JDK16")]),_:1})]),t("li",null,[e(i,{to:"/audition/java/new/jdk17.html"},{default:a(()=>[l("JDK17")]),_:1})]),t("li",null,[e(i,{to:"/audition/java/new/jdk18.html"},{default:a(()=>[l("JDK18")]),_:1})]),t("li",null,[e(i,{to:"/audition/java/new/jdk19.html"},{default:a(()=>[l("JDK19")]),_:1})]),t("li",null,[e(i,{to:"/audition/java/new/jdk20.html"},{default:a(()=>[l("JDK20")]),_:1})]),t("li",null,[e(i,{to:"/audition/java/new/jdk21.html"},{default:a(()=>[l("JDK21")]),_:1})])])])]),b])}const K=n(p,[["render",y],["__file","index.html.vue"]]),q=JSON.parse('{"path":"/audition/java/","title":"Java","lang":"zh-CN","frontmatter":{"title":"Java","icon":"java","category":"面试题","tag":"面试题","timeline":true,"star":true,"description":"此处是一些 Java 高频面试题（持续更新中...）。 目录 基础 集合 并发编程 IO JVM 新特性 面试题汇总 常见集合面试题 Java 集合体系。 Java集合体系 ArrayList 底层的数据结构和扩容的机制。 每次扩容是原来的 1.5 倍。 如何实现数组和 List 之间的转换？ 数组转 List：Arrays.asList(T... a...","head":[["meta",{"property":"og:url","content":"https://SuperChenWenjing.github.io/audition/java/"}],["meta",{"property":"og:site_name","content":"陈文景"}],["meta",{"property":"og:title","content":"Java"}],["meta",{"property":"og:description","content":"此处是一些 Java 高频面试题（持续更新中...）。 目录 基础 集合 并发编程 IO JVM 新特性 面试题汇总 常见集合面试题 Java 集合体系。 Java集合体系 ArrayList 底层的数据结构和扩容的机制。 每次扩容是原来的 1.5 倍。 如何实现数组和 List 之间的转换？ 数组转 List：Arrays.asList(T... a..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-05T08:06:48.000Z"}],["meta",{"property":"article:author","content":"陈文景"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:modified_time","content":"2024-05-05T08:06:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-05T08:06:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"陈文景\\",\\"email\\":\\"2646530197@qq.com\\",\\"url\\":\\"https://superchenwenjing.github.io\\"}]}"]],"date":"2024-03-08T16:03:07.000Z"},"headers":[{"level":2,"title":"目录","slug":"目录","link":"#目录","children":[{"level":3,"title":"基础","slug":"基础","link":"#基础","children":[]},{"level":3,"title":"集合","slug":"集合","link":"#集合","children":[]},{"level":3,"title":"并发编程","slug":"并发编程","link":"#并发编程","children":[]},{"level":3,"title":"IO","slug":"io","link":"#io","children":[]},{"level":3,"title":"JVM","slug":"jvm","link":"#jvm","children":[]},{"level":3,"title":"新特性","slug":"新特性","link":"#新特性","children":[]}]},{"level":2,"title":"面试题汇总","slug":"面试题汇总","link":"#面试题汇总","children":[{"level":3,"title":"常见集合面试题","slug":"常见集合面试题","link":"#常见集合面试题","children":[]},{"level":3,"title":"多线程面试题","slug":"多线程面试题","link":"#多线程面试题","children":[]}]}],"git":{"createdTime":1709913787000,"updatedTime":1714896408000,"contributors":[{"name":"陈文景","email":"2646530197@qq.com","commits":2}]},"readingTime":{"minutes":2.5,"words":749},"filePathRelative":"audition/java/README.md","localizedDate":"2024年3月8日","excerpt":"<p>此处是一些 Java 高频面试题（持续更新中...）。</p>\\n","autoDesc":true}');export{K as comp,q as data};
