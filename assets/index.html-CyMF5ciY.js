import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as p,c as l,b as r,d as n,a as i,w as t,f as c,e}from"./app-DxXMMQNo.js";const d="/assets/AOP应用场景-记录日志-BOR3mgUv.png",g="/assets/Spring中Bean的生命周期-BqFeQDIX.png",u="/assets/Bean的生命周期简单版-B6EF5ibK.png",m="/assets/循环引用示例-CJ522tCQ.png",h="/assets/三级缓存-9XaRCa88.png",k="/assets/循环依赖的解决方案-CtN9RWeh.png",v="/assets/SpringMVC视图阶段-Dpww825r.png",S="/assets/前后端分离阶段-Dg7pJQ6H.png",b="/assets/Spring框架常见注解-C1j4Qav2.png",B="/assets/SpringBootApplication注解-DyaY3VvR.png",_="/assets/SpringBoot自动装配的流程1-DMw8wR7K.png",f="/assets/SpringBoot自动装配的流程2-DvL7nU_z.png",y={},C=n("div",{class:"hint-container note"},[n("p",{class:"hint-container-title"},"注"),n("p",null,"此处是一些 Spring 高频面试题（持续更新中...）。")],-1),q=n("h2",{id:"目录",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#目录"},[n("span",null,"目录")])],-1),A=n("h3",{id:"spring",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#spring"},[n("span",null,"Spring")])],-1),w=c(`<h2 id="面试题汇总" tabindex="-1"><a class="header-anchor" href="#面试题汇总"><span>面试题汇总</span></a></h2><h3 id="springframework" tabindex="-1"><a class="header-anchor" href="#springframework"><span>SpringFramework</span></a></h3><div class="hint-container info"><p class="hint-container-title">Spring 框架中的 Bean 是线程安全的吗？</p><blockquote><p>不是线程安全的。</p><p>Spring 框架的 Bean 默认是单例的。</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Service</span>
<span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span><span class="token string">&quot;singleton&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre></div><p>singleton：Bean 在每个 Spring IOC 容器中只有一个实例（默认）。</p><p>prototype：一个 Bean 的定义可以有多个实例。</p><p>但 Spring Bean 并没有可变的状态（比如 Service 类和 DAO 类），所以在某种程度上说 Spring 的单例 Bean 是线程安全的。</p><p><strong>参考回答</strong>：</p><p>不是线程安全的。</p><p>Spring 框架中有一个 <code>@Scope</code> 注解，默认的值就是 singleton，单例的。</p><p>因为一般在 Spring 容器中的 Bean 都是注入的无状态对象，是没有线程安全问题的，如果在 Bean 中定义了可修改的成员变量，是要考虑线程安全问题的，可以使用多例或者加锁来解决。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">什么是 AOP ？你们项目中有没有使用到 AOP ？</p><blockquote><p><strong>AOP 称为面向切面编程</strong>：用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</p><p><strong>常见的AOP使用场景</strong>：记录操作日志、缓存处理、Spring 中内置的事务处理。</p><p>记录操作日志思路：获取请求的用户名、请求方式、访问地址、模块名称、登录 IP、操作时间，记录到数据库的日志表中。</p><p><img src="`+d+`" alt="AOP应用场景-记录日志" loading="lazy"></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">&quot;pointcut()&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">around</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//  获取用户名</span>
  <span class="token comment">// 获取请求方式</span>
  <span class="token comment">// 获取访问结果</span>
  <span class="token comment">// 获取模块名称</span>
  <span class="token comment">// 登录 IP</span>
  <span class="token comment">// 操作时间</span>
  <span class="token comment">// 保存到数据库（操作日志）    </span>
  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例代码如上：使用 AOP 中的环绕通知 + 切点表达式（找到要记录日志的方法）。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">Spring 中的事务是如何实现的？</p><blockquote><p>Spring 支持编程式事务管理和声明式事务管理两种方式：</p><ul><li>编程式事务控制：需使用 TransactionTemplate 来进行实现，对业务代码有侵入性，所以项目中很少使用。</li><li>声明式事务管理：声明式事务管理建立在 AOP 之上的。其本质是通过 AOP 功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</li></ul><p>声明式事务的核心注解：<code>@Transactional</code>。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">Spring 中事务失效的场景有哪些？</p><blockquote><p>异常捕获处理：自己通过 <code>try{} catch{}</code> 捕获了异常又不主动抛出异常。</p><p>抛出检查异常：Spring 默认只会回滚非检查异常（解决：<code>@Transactional(rollbackFor=Exception.class)</code>）。</p><p>非 <code>public</code> 方法：Spring 为方法创建代理、添加事务通知、前提条件都是该方法是 <code>public</code> 的。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">Spring 的 Bean 的生命周期。</p><blockquote><p><img src="`+g+'" alt="Spring中Bean的生命周期" loading="lazy"></p><p><strong>文字描述</strong>：</p><ol><li>通过 BeanDefinition 获取 Bean 的定义信息。</li><li>调用构造函数实例化 Bean。</li><li>Bean 的依赖注入。</li><li>处理 Aware 接口（BeanNameAware、BeanFactoryAware、ApplicationContextAware）。</li><li>Bean 的后置处理器 BeanPostProcessor-前置。</li><li>初始化方法（InitializingBean、init-method）。</li><li>Bean 的后置处理器 BeanPostProcessor-后置。</li><li>销毁 Bean。</li></ol><img src="'+u+'" alt="Bean的生命周期简单版" style="zoom:50%;"></blockquote></div><div class="hint-container info"><p class="hint-container-title">Spring 中的循环引用。</p><blockquote><p>循环引用示例：</p><p><img src="'+m+'" alt="循环引用示例" loading="lazy"></p><p><strong>Spring 是通过三级缓存解决循环依赖问题的。</strong></p><p><img src="'+h+'" alt="三级缓存" loading="lazy"></p><p><img src="'+k+`" alt="循环依赖的解决方案" loading="lazy"></p><p><strong>文字描述</strong>：</p><ul><li>循环依赖：循环依赖其实就是循环引用，也就是两个或两个以上的 Bean 互相持有对方，最终形成闭环（比如 A 依赖于 B，B 依赖于 A）。</li><li>循环依赖在 Spring 中是允许存在，Spring 框架依据三级缓存已经解决了大部分的循环依赖问题： <ol><li>一级缓存：单例池，缓存已经经历了完整的生命周期，已经初始化完成的 Bean 对象。</li><li>二级缓存：缓存早期的 Bean 对象（生命周期还没走完）。</li><li>三级缓存：缓存的是 ObjectFactory，表示对象工厂，用来创建某个对象的。</li></ol></li></ul></blockquote></div><div class="hint-container info"><p class="hint-container-title">构造方法出现了循环依赖怎么解决？</p><blockquote><p>原因：由于 Bean 的生命周期中构造函数是第一个执行的，所以 Spring 框架并不能解决构造函数的的依赖注入。</p><p>解决方案：使用 <code>@Lazy</code> 懒加载注解解决，什么时候需要对象再进行 Bean 对象的创建。</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Lazy</span> <span class="token class-name">B</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;A的构造方法执行了...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></blockquote></div><div class="hint-container info"><p class="hint-container-title">。</p><blockquote></blockquote></div><h3 id="springmvc" tabindex="-1"><a class="header-anchor" href="#springmvc"><span>SpringMVC</span></a></h3><div class="hint-container info"><p class="hint-container-title">SpringMVC 的执行流程知道嘛？</p><blockquote><p><strong>视图阶段（老旧 JSP 项目）</strong>：</p><p><img src="`+v+'" alt="SpringMVC视图阶段" loading="lazy"></p><p>文字描述（视图阶段）：</p><ol><li>用户发送出请求到前端控制器 DispatcherServlet。</li><li>DispatcherServlet 收到请求调用 HandlerMapping（处理器映射器）。</li><li>HandlerMapping 找到具体的处理器，生成处理器对象及处理器拦截器（如果有），再一起返回给 DispatcherServlet。</li><li>DispatcherServlet 调用 HandlerAdapter（处理器适配器）。</li><li>HandlerAdapter 经过适配调用具体的处理器（Handler/Controller）。</li><li>Controller 执行完成返回 ModelAndView 对象。</li><li>HandlerAdapter 将 Controller 执行结果 ModelAndView 返回给 DispatcherServlet。</li><li>DispatcherServlet 将 ModelAndView 传给 ViewReslover（视图解析器）。</li><li>ViewReslover 解析后返回具体 View（视图）。</li><li>DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。</li><li>DispatcherServlet 响应用户。</li></ol><p><strong>前后端分离阶段（接口开发）</strong>：</p><p><img src="'+S+'" alt="前后端分离阶段" loading="lazy"></p><p>文字描述（前后端分离阶段）：</p><ol><li>用户发送出请求到前端控制器 DispatcherServlet。</li><li>DispatcherServlet 收到请求调用 HandlerMapping（处理器映射器）。</li><li>HandlerMapping 找到具体的处理器，生成处理器对象及处理器拦截器（如果有），再一起返回给 DispatcherServlet。</li><li>DispatcherServlet 调用 HandlerAdapter（处理器适配器）。</li><li>HandlerAdapter 经过适配调用具体的处理器（Handler/Controller）。</li><li>方法上添加了@ResponseBody。</li><li>通过 HttpMessageConverter 来返回结果转换为 JSON 并响应。</li></ol></blockquote></div><div class="hint-container info"><p class="hint-container-title">Spring 框架常见的注解有哪些？</p><blockquote><p>Spring 的常见注解有哪些？</p><p><img src="'+b+'" alt="Spring框架常见注解" loading="lazy"></p><p>SpringMVC 常见的注解有哪些？</p><p>![SpringMVC 常见的注解](./assets/SpringMVC 常见的注解.png)</p><p>SpringBoot 常见注解有哪些？</p><p>![SpringBoot 常见注解](./assets/SpringBoot 常见注解.png)</p></blockquote></div><h3 id="springboot" tabindex="-1"><a class="header-anchor" href="#springboot"><span>SpringBoot</span></a></h3><div class="hint-container info"><p class="hint-container-title">SpringBoot 自动配置原理。</p><blockquote><p><img src="'+B+'" alt="SpringBootApplication注解" loading="lazy"></p><p><code>@SpringBootConfiguration</code>：该注解与 <code>@Configuration</code> 注解作用相同，用来声明当前也是一个配置类。</p><p><code>@ComponentScan</code>：组件扫描，默认扫描当前引导类所在包及其子包。</p><p><code>@EnableAutoConfiguration</code>：SpringBoot 实现自动化配置的核心注解。</p><p><img src="'+_+'" alt="SpringBoot自动装配的流程1" loading="lazy"></p><p><img src="'+f+'" alt="SpringBoot自动装配的流程2" loading="lazy"></p><p><strong>文字描述</strong>：</p><ol><li>在 SpringBoot 项目中的引导类上有一个注解 <code>@SpringBootApplication</code>，这个注解是对三个注解进行了封装，分别是： <ul><li><code>@SpringBootConfiguration</code>。</li><li><code>@EnableAutoConfiguration</code>。</li><li><code>@ComponentScan</code>。</li></ul></li><li>其中 <code>@EnableAutoConfiguration</code> 是实现自动化配置的核心注解： <ul><li>该注解通过 <code>@Import</code> 注解导入对应的配置选择器。</li><li>内部就是读取了该项目和该项目引用的 Jar 包的的 classpath 路径下 META-INF/spring.factories 文件中的所配置的类的全类名。</li><li>在这些配置类中所定义的 Bean 会根据条件注解所指定的条件来决定是否需要将其导入到 Spring 容器中。</li></ul></li><li>条件判断会有像 <code>@ConditionalOnClass</code> 这样的注解，判断是否有对应的 Class 文件，如果有则加载该类，把这个配置类的所有的 Bean 放入 Spring 容器中使用。</li></ol></blockquote></div><div class="hint-container info"><p class="hint-container-title">。</p><blockquote></blockquote></div><h3 id="springcloud" tabindex="-1"><a class="header-anchor" href="#springcloud"><span>SpringCloud</span></a></h3><div class="hint-container info"><p class="hint-container-title">。</p><blockquote></blockquote></div><div class="hint-container info"><p class="hint-container-title">。</p><blockquote></blockquote></div><div class="hint-container info"><p class="hint-container-title">。</p><blockquote></blockquote></div>',20);function D(V,x){const a=o("RouteLink");return p(),l("div",null,[C,r(" more "),q,A,n("ul",null,[n("li",null,[i(a,{to:"/audition/spring/spring-framework/"},{default:t(()=>[e("SpringFramework")]),_:1})]),n("li",null,[i(a,{to:"/audition/spring/spring-mvc/"},{default:t(()=>[e("SpringMVC")]),_:1})]),n("li",null,[i(a,{to:"/audition/spring/spring-boot/"},{default:t(()=>[e("SpringBoot")]),_:1})]),n("li",null,[i(a,{to:"/audition/spring/spring-security/"},{default:t(()=>[e("SpringSecurity")]),_:1})]),n("li",null,[i(a,{to:"/audition/spring/spring-cloud/"},{default:t(()=>[e("SpringCloud")]),_:1})])]),w])}const j=s(y,[["render",D],["__file","index.html.vue"]]),z=JSON.parse('{"path":"/audition/spring/","title":"Spring","lang":"zh-CN","frontmatter":{"title":"Spring","icon":"spring","category":"面试题","tag":"面试题","timeline":true,"star":true,"description":" 注 此处是一些 Spring 高频面试题（持续更新中...）。 目录 Spring 面试题汇总 SpringFramework Spring 框架中的 Bean 是线程安全的吗？ 不是线程安全的。 Spring 框架的 Bean 默认是单例的。 singleton：Bean 在每个 Spring IOC 容器中只有一个实例（默认）。 prototyp...","head":[["meta",{"property":"og:url","content":"https://SuperChenWenjing.github.io/audition/spring/"}],["meta",{"property":"og:site_name","content":"陈文景"}],["meta",{"property":"og:title","content":"Spring"}],["meta",{"property":"og:description","content":" 注 此处是一些 Spring 高频面试题（持续更新中...）。 目录 Spring 面试题汇总 SpringFramework Spring 框架中的 Bean 是线程安全的吗？ 不是线程安全的。 Spring 框架的 Bean 默认是单例的。 singleton：Bean 在每个 Spring IOC 容器中只有一个实例（默认）。 prototyp..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-04T07:51:51.000Z"}],["meta",{"property":"article:author","content":"陈文景"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:modified_time","content":"2024-05-04T07:51:51.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Spring\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-04T07:51:51.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"陈文景\\",\\"email\\":\\"2646530197@qq.com\\",\\"url\\":\\"https://superchenwenjing.github.io\\"}]}"]],"date":"2024-03-08T16:03:07.000Z"},"headers":[{"level":2,"title":"目录","slug":"目录","link":"#目录","children":[{"level":3,"title":"Spring","slug":"spring","link":"#spring","children":[]}]},{"level":2,"title":"面试题汇总","slug":"面试题汇总","link":"#面试题汇总","children":[{"level":3,"title":"SpringFramework","slug":"springframework","link":"#springframework","children":[]},{"level":3,"title":"SpringMVC","slug":"springmvc","link":"#springmvc","children":[]},{"level":3,"title":"SpringBoot","slug":"springboot","link":"#springboot","children":[]},{"level":3,"title":"SpringCloud","slug":"springcloud","link":"#springcloud","children":[]}]}],"git":{"createdTime":1709913787000,"updatedTime":1714809111000,"contributors":[{"name":"陈文景","email":"2646530197@qq.com","commits":3}]},"readingTime":{"minutes":6.94,"words":2082},"filePathRelative":"audition/spring/README.md","localizedDate":"2024年3月8日","excerpt":"<div class=\\"hint-container note\\">\\n<p class=\\"hint-container-title\\">注</p>\\n<p>此处是一些 Spring 高频面试题（持续更新中...）。</p>\\n</div>\\n","autoDesc":true}');export{j as comp,z as data};
