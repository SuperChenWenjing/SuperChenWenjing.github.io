---
title: 高级
icon: Code
# date: 2019-12-26
category: Java
timeline: true
star: true
---

## 抽象类

::: tip 什么是抽象类和抽象方法？

被 `abstract` 关键字修饰的类称为抽象类、被 `abstract` 关键字修饰的**没有方法体的方法**则称为抽象方法。

抽象类语法格式：

```java
[权限修饰符] abstract class 类名{ }
[权限修饰符] abstract class 类名 extends 父类{ }
```

抽象方法语法格式：

```java
[权限修饰符] abstract 返回值类型 方法名([形参列表]);
```

**注意：**

- **抽象类不能创建对象**。
- 抽象类是用来被继承的。
- 抽象类中可以没有抽象方法，但是有抽象方法的类一定是抽象类。
- 继承抽象类的子类需要实现抽象类中的所有抽象方法，否则自己也要成为抽象类。

`abstract` 关键字的注意事项：

- 不能使用 `abstract` 关键字修饰变量、代码块、构造器。
- 不能使用 `abstract` 关键字修饰私有方法、静态方法、`final` 修饰的方法、`final` 修饰的类。

:::

## 接口（interface）

::: tip 什么是接口？

接口可以理解为一种规范，定义了一组规则，体现了现实世界中“如果你是/要...则必须...“的思想。

接口的定义格式：

```java
[修饰符] interface 接口名{
  // 接口的成员列表
  // 公共的静态常量
  // 公共的抽象方法
  // 公共的默认方法（JDK1.8 以上）
  // 公共的静态方法（JDK1.8 以上）
  // 私有方法（JDK1.9 以上）
}
```

**JDK8.0 之前的接口中只允许出现：**

- 公共的静态常量：其中 `public static final` 可以省略。
- 公共的抽象方法：其中 `public abstract` 可以省略。

**JDK8.0 的接口中允许声明默认方法和静态方法：**

- 公共的默认方法（使用 `default` 关键字修饰 - 不能省略）：其中 `public` 可以省略（但建议保留）。

  - 需要用接口的实现类的对象来调用。

    ```java
    default 返回值类型 方法名() {}
    ```

- 公共的静态方法（使用 `static` 关键字修饰 - 不能省略）：其中 `public` 可以省略（但建议保留）。

  - 接口的静态方法必须用本身的接口名来调用。

    ```java
    static 返回值类型 方法名() {}
    ```

**JDK9.0 的接口中允许声明私有方法：**

- 私有方法（使用 `private` 关键字修饰 - 不能省略）。

  - 只能在本类中被其他的默认方法或者私有方法访问。

    ```java
    private 返回值类型 方法名() {}
    ```

**补充说明：**接口中没有构造器、没有代码块，因为接口中没有成员变量需要动态初始化。

**注意：**

- **接口不能创建对象**。
- 如果一个类既继承类又实现接口，则继承在前实现在后。
- 接口可以被类单实现、也可以多实现（接口可以单继承或多继承其它接口）。
- 一个类实现了接口，就必须重写完接口中的全部抽象方法，否则这个类需要被定义成抽象类。
- 一个类实现多个接口，多个接口的规范不能冲突。
- 一个类实现多个接口，多个接口中有同样的静态方法不冲突。
- 一个类继承了父类，同时又实现了接口，父类中和接口中有同名方法，默认用父类的。
- 一个类实现了多个接口，多个接口中存在同名的默认方法，可以不冲突，这个类重写该方法即可。
- 一个接口继承多个接口，是没有问题的，如果多个接口中存在规范冲突则不能多继承。

:::

## 内部类

::: tip 什么是内部类？

将一个类 A 定义在另一个类 B 的内部，则里面的那个类 A 就称为内部类。

内部类的分类：

- 静态内部类。

  ```java
  public class Outer {
    // 静态内部类
    public static class Inner {}
  }
  
  // 外部类名.内部类名 对象名称 = new 外部类名.内部类构造器();
  Outer.Inner inner = new Outer.Inner();
  ```

- 成员内部类。

  ```java
  public class Outer {
    // 成员内部类
    public class Inner {}
  }
  
  // 外部类名.内部类名 对象名称 = new 外部类构造器().new 内部类构造器();
  Outer.Inner inner = new Outer().new Inner();
  ```

- 局部内部类。

  鸡肋语法、知道即可。

- 匿名内部类。

  ```java
  // 格式：
  // new 类名称 | 抽象类名称 | 接口名称 () {
  //   重写方法;
  // };
  
  // 范例：
  Employee employee = new Employee() {
    public void work() { }
  };
  employee. work();
  ```

  匿名内部类的特点总结：

  - 匿名内部类是一个**没有名字的内部类，同时也代表一个对象**。
  - **匿名内部类产生的对象类型，相当于是当前`new`的那个的类型的子类类型**。
  - 匿名内部类可以作为一个对象，直接传输给方法。
  - 匿名内部类通常是在开发中调用别人的方法时，别人需要我们写的时候才会定义出来使用。
  - 匿名内部类还可以通过`Lambda`表达式实现进一步的简化代码。

:::

## 枚举类

::: tip 什么是枚举类？

枚举是 Java 中的一种特殊类型。

枚举的作用：是为了做信息的标志和信息的分类。

```java
修饰符 enum 枚举名称 {
  枚举实例的名称（每个枚举实例都是该枚举类的实例对象）
}
```

**枚举类的特征：**

- 枚举类都是继承了枚举类型 `java.lang.Enum`。
- **枚举都是最终类，不可以被继承**。
- **构造器都是私有的，枚举对外不能创建对象**。
- 枚举类相当于是多例模式。

:::

## 注解

::: tip 什么是注解？

Annotation 可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。

元注解（注解的注解）：

- @Target：用于描述注解的使用范围。
  - 可以通过枚举类型 ElementType 的 10 个常量对象来指定。
- @Retention：用于描述注解的生命周期。
  - 可以通过枚举类型 RetentionPolicy 的 3 个常量对象来指定。
  - SOURCE（源代码）、CLASS（字节码）、RUNTIME（运行时）。
  - 唯有 RUNTIME 阶段才能被反射读取到。
- @Documented：表明这个注解应该被 JavaDoc 工具记录。
- @Inherited：允许子类继承父类中的注解。

**自定义注解：**

一个完整的注解应该包含三个部分：声明、使用、读取。

```java
@元注解
[修饰符] @interface 注解名 {
  // 成员列表
}
```

注：需配合反射技术实现（待补充完整）。

:::
