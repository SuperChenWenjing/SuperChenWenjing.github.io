---
title: 面向对象
icon: Code
# date: 2019-12-26
category: Java
timeline: true
star: true
---

## 基础

### 关于继承

**继承的特点：**

- 子类可以继承父类的属性和行为，但是子类不能继承父类的构造器。
- **Java是单继承模式：一个类只能继承一个直接父类。**
- Java不支持多继承、但是支持多层继承。
- Java中所有的类都是Object类的子类。

**引发的思考：**

- 子类是否可以继承父类的构造器？

  不可以的，子类有自己的构造器，父类构造器用于初始化父类对象。

- 子类是否可以继承父类的私有成员？

  可以的，只是不能直接访问。

  子类虽然会继承父类的私有（private）的成员变量，但是子类不能直接对继承的私有成员变量进行访问，可以通过继承的 `get/set`方法进行访问。

- 子类是否可以继承父类的静态成员？

  有争议的知识点。

  子类可以直接使用父类的静态成员（共享）。

  但个人认为：子类不能继承父类的静态成员（共享并非继承）。

### 权限修饰符

::: tip 权限修饰符（访问控制修饰符）是什么？

用于限制类中的成员（成员变量、成员方法、构造器、代码块、...）能够被访问的范围。

:::

**权限修饰符（访问控制修饰符）：**

| 修饰符      | 同一个类中 | 同一个包中的其它类 | 不同包下的子类 | 不同包下的无关类 |
| ----------- | ---------- | ------------------ | -------------- | ---------------- |
| `private`   | ✅          | ❌                  | ❌              | ❌                |
| `缺省`      | ✅          | ✅                  | ❌              | ❌                |
| `protected` | ✅          | ✅                  | ✅              | ❌                |
| `public`    | ✅          | ✅                  | ✅              | ✅                |

> 控制范围：`private` < `缺省` < `protected` < `public`。

::: warning

构造器的修饰符只能是权限修饰符，不能被其他任何修饰。

例如：不能被 `static`、`final`、`synchronized`、`abstract`、`native` 修饰，不能有 `return` 语句返回值。

对于 `static final` 的成员变量，习惯上使用 `public` 修饰（常量）。

:::

## 进阶

### 多态

::: tip 什么是多态？

父类的引用指向子类的对象。

多态的前提条件：

- 有<strong style="color: #fb9b5f">继承</strong>/<strong style="color: #fb9b5f">实现</strong>关系。
- 有<strong style="color: #fb9b5f">父类引用指向子类对象</strong>。
- <strong style="color: #fb9b5f">有方法重写（多态侧重行为多态）</strong>。

多态格式：`父类类型 变量名 = new 子类类型()`。

多态下会产生的一个问题：

- <strong style="color: #fb9b5f">多态下不能使用子类的独有功能</strong>。
- 需要强制类型转换（从父到子）。
- 建议在类型转换前先通过 `instanceof` 关键字校验需要转换的类是否是由该父类产生的。
- 否则会出现 ClassCastException 类型转换异常的错误。

:::

多态中成员的访问特点？

- 方法调用：编译看左边，运行看右边。
- 变量调用：编译看左边，运行也看左边。

多态的前提？

- 有继承/实现的关系。
- 有父类的引用指向子类对象。
- 有方法重写（多态注重行为多态）。

多态的优点和缺点？

- 优点：实现接触耦合，便于扩展。
- 缺点：多态下不能使用子类独有的功能（如果要使用子类的独有功能则需要强制类型转换）。

### 面试题

**请问 `==` 和 `equals` 方法有什么区别？**

- `==` 既可以比较基本数据类型也可以比较引用数据类型。
  - 对于基本数据类型比较的是值。
  - 对于引用数据类型比较的是内存地址。
- `equals` 是属于 `java.lang.Object` 类中的方法。
  - 如果该方法没有被重写过：则默认与 `==` 的比较逻辑一致。
  - 如果该方法有被重写过：通常情况下，我们重写 `equals` 方法会用于比较类中相应的属性是否相等。

## 高级

### 抽象类

::: tip 什么是抽象类和抽象方法？

被 `abstract` 关键字修饰的类称为抽象类、被 `abstract` 关键字修饰的**没有方法体的方法**则称为抽象方法。

抽象类语法格式：

```java
[权限修饰符] abstract class 类名{ }
[权限修饰符] abstract class 类名 extends 父类{ }
```

抽象方法语法格式：

```java
[权限修饰符] abstract 返回值类型 方法名([形参列表]);
```

**注意：**

- **抽象类不能创建对象**。
- 抽象类是用来被继承的。
- 抽象类中可以没有抽象方法，但是有抽象方法的类一定是抽象类。
- 继承抽象类的子类需要实现抽象类中的所有抽象方法，否则自己也要成为抽象类。

`abstract` 关键字的注意事项：

- 不能使用 `abstract` 关键字修饰变量、代码块、构造器。
- 不能使用 `abstract` 关键字修饰私有方法、静态方法、`final` 修饰的方法、`final` 修饰的类。

:::

### 接口（interface）

::: tip 什么是接口？

接口可以理解为一种规范，定义了一组规则，体现了现实世界中“如果你是/要...则必须...“的思想。

接口的定义格式：

```java
[修饰符] interface 接口名{
  // 接口的成员列表
  // 公共的静态常量
  // 公共的抽象方法
  // 公共的默认方法（JDK1.8 以上）
  // 公共的静态方法（JDK1.8 以上）
  // 私有方法（JDK1.9 以上）
}
```

**JDK8.0 之前的接口中只允许出现：**

- 公共的静态常量：其中 `public static final` 可以省略。
- 公共的抽象方法：其中 `public abstract` 可以省略。

**JDK8.0 的接口中允许声明默认方法和静态方法：**

- 公共的默认方法（使用 `default` 关键字修饰 - 不能省略）：其中 `public` 可以省略（但建议保留）。

  - 需要用接口的实现类的对象来调用。

    ```java
    default 返回值类型 方法名() {}
    ```

- 公共的静态方法（使用 `static` 关键字修饰 - 不能省略）：其中 `public` 可以省略（但建议保留）。

  - 接口的静态方法必须用本身的接口名来调用。

    ```java
    static 返回值类型 方法名() {}
    ```

**JDK9.0 的接口中允许声明私有方法：**

- 私有方法（使用 `private` 关键字修饰 - 不能省略）。

  - 只能在本类中被其他的默认方法或者私有方法访问。

    ```java
    private 返回值类型 方法名() {}
    ```

**补充说明：**接口中没有构造器、没有代码块，因为接口中没有成员变量需要动态初始化。

**注意：**

- **接口不能创建对象**。
- 如果一个类既继承类又实现接口，则继承在前实现在后。
- 接口可以被类单实现、也可以多实现（接口可以单继承或多继承其它接口）。
- 一个类实现了接口，就必须重写完接口中的全部抽象方法，否则这个类需要被定义成抽象类。
- 一个类实现多个接口，多个接口的规范不能冲突。
- 一个类实现多个接口，多个接口中有同样的静态方法不冲突。
- 一个类继承了父类，同时又实现了接口，父类中和接口中有同名方法，默认用父类的。
- 一个类实现了多个接口，多个接口中存在同名的默认方法，可以不冲突，这个类重写该方法即可。
- 一个接口继承多个接口，是没有问题的，如果多个接口中存在规范冲突则不能多继承。

:::

### 内部类

::: tip 什么是内部类？

将一个类 A 定义在另一个类 B 的内部，则里面的那个类 A 就称为内部类。

内部类的分类：

- 静态内部类。

  ```java
  public class Outer {
    // 静态内部类
    public static class Inner {}
  }
  
  // 外部类名.内部类名 对象名称 = new 外部类名.内部类构造器();
  Outer.Inner inner = new Outer.Inner();
  ```

- 成员内部类。

  ```java
  public class Outer {
    // 成员内部类
    public class Inner {}
  }
  
  // 外部类名.内部类名 对象名称 = new 外部类构造器().new 内部类构造器();
  Outer.Inner inner = new Outer().new Inner();
  ```

- 局部内部类。

  鸡肋语法、知道即可。

- 匿名内部类。

  ```java
  // 格式：
  // new 类名称 | 抽象类名称 | 接口名称 () {
  //   重写方法;
  // };
  
  // 范例：
  Employee employee = new Employee() {
    public void work() { }
  };
  employee. work();
  ```

  匿名内部类的特点总结：

  - 匿名内部类是一个**没有名字的内部类，同时也代表一个对象**。
  - **匿名内部类产生的对象类型，相当于是当前`new`的那个的类型的子类类型**。
  - 匿名内部类可以作为一个对象，直接传输给方法。
  - 匿名内部类通常是在开发中调用别人的方法时，别人需要我们写的时候才会定义出来使用。
  - 匿名内部类还可以通过`Lambda`表达式实现进一步的简化代码。

:::

### 枚举类

::: tip 什么是枚举类？

枚举是 Java 中的一种特殊类型。

枚举的作用：是为了做信息的标志和信息的分类。

```java
修饰符 enum 枚举名称 {
  枚举实例的名称（每个枚举实例都是该枚举类的实例对象）
}
```

**枚举类的特征：**

- 枚举类都是继承了枚举类型 `java.lang.Enum`。
- **枚举都是最终类，不可以被继承**。
- **构造器都是私有的，枚举对外不能创建对象**。
- 枚举类相当于是多例模式。

:::

### 注解

::: tip 什么是注解？

Annotation 可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。

元注解（注解的注解）：

- @Target：用于描述注解的使用范围。
  - 可以通过枚举类型 ElementType 的 10 个常量对象来指定。
- @Retention：用于描述注解的生命周期。
  - 可以通过枚举类型 RetentionPolicy 的 3 个常量对象来指定。
  - SOURCE（源代码）、CLASS（字节码）、RUNTIME（运行时）。
  - 唯有 RUNTIME 阶段才能被反射读取到。
- @Documented：表明这个注解应该被 JavaDoc 工具记录。
- @Inherited：允许子类继承父类中的注解。

**自定义注解：**

一个完整的注解应该包含三个部分：声明、使用、读取。

```java
@元注解
[修饰符] @interface 注解名 {
  // 成员列表
}
```

注：需配合反射技术实现（待补充完整）。

:::
