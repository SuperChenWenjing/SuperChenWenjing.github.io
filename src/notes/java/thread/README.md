---
title: 并发编程
icon: Code
# date: 2019-12-26
category:
  - Java
  - 并发编程
timeline: true
star: true
---

## 一、进程和线程

### 1.1 进程

- 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。
- 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。
- 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器...），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士...）。

### 1.2 线程

- 一个进程之内可以分为一到多个线程。
- 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行。
- 在 Java 中，线程作为最小的调度单位，进程作为资源分配的最小单位。 
- 在 Windows 中进程是不活动的，只是作为线程的容器。

### 1.3 二者对比

- 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集。
- 进程拥有共享的资源，如内存空间等，供其内部的线程共享。
- 进程间通信较为复杂：
  - 同一台计算机的进程通信称为 IPC（Inter-process communication）。
  - 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP。
- 线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量。
- 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低。

## 二、并发与并行

在单核 CPU 下，线程实际还是**串行执行**的。

操作系统中有一个组件叫做**任务调度器**，将 CPU 的时间片（Windows 下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 CPU 在线程间（时间片很短）的切换非常快，人类感觉是**同时运行的**。

总结为一句话就是： **微观串行**，**宏观并行** ，一般会将这种线程轮流使用 CPU 的做法称为并发（Concurrent）。

| CPU  | 时间片1 | 时间片2 | 时间片3 | 时间片4 |
| ---- | ------- | ------- | ------- | ------- |
| Core | 线程1   | 线程2   | 线程3   | 线程4   |

在多核 CPU 下，每个 核（Core） 都可以调度运行线程，这时候线程可以是并行的。

| CPU  | 时间片1 | 时间片2 | 时间片3 | 时间片4 |
| ---- | ------- | ------- | ------- | ------- |
| Core | 线程1   | 线程1   | 线程3   | 线程3   |
| Core | 线程2   | 线程4   | 线程2   | 线程4   |

引用 Rob Pike 的一段描述：

- 并发（Concurrent）是同一时间应对（Dealing With）多件事情的能力。
- 并行（Parallel）是同一时间动手做（Doing）多件事情的能力。

举个例子：

- 家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发。
- 家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一个人用锅时，另一个人就得等待）。
- 雇了 3 个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行。

::: note Rob Pike

- Golang 语言的创造者。
- Rob Pike - [百度百科](https://baike.baidu.com/item/%E7%BD%97%E5%B8%83%C2%B7%E6%B4%BE%E5%85%8B/10983505?fr=ge_ala)。

:::

## 三、实际应用场景

### 3.1 应用之异步调用

以调用的方角度来讲：

- 如果需要等待结果返回，才能继续运行的就是同步。
- 如果不需要等待结果返回，就能继续运行的就是异步。

#### 3.1.1 设计

多线程可以让方法执行变为异步的（就是不用干巴巴的等着）。

比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如果没有线程调度机制，那这 5 秒 CPU 就什么都做不了，其它代码也都得暂停等待。

#### 3.1.2 结论

- 比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程。
- Tomcat 的异步 Servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 Tomcat 的工作线程。

### 3.2 应用之提高效率

充分利用多核 CPU 的优势来提高运行效率。

想象下面的场景，执行 3 个计算，最后将计算结果汇总。

- 计算 1 花费 10ms。
- 计算 2 花费 11ms。
- 计算 3 花费 9ms。
- 汇总则需要 1ms。

如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 = 31ms。
但如果是四核 CPU，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms 最后加上汇总时间只会花费 12ms。

::: warning 注意！

需要在多核 CPU 才能提高效率，单核仍然时是轮流执行的！

:::

#### 3.2.1 设计

待添加案例代码示例！

#### 3.2.2 结论

1. 单核 CPU 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 CPU ，不至于一个线程总占用 CPU，别的线程没法干活。
2. 多核 CPU 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的：
   - 有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分。
   - 也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义。
3.  IO 操作不占用 CPU，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 CPU，但需要一直等待 IO 结束，没能充分利用线程（可以通过【非阻塞 IO】和【异步 IO】优化）。

## 四、Java中的线程

### 4.1 创建和运行线程

**方式一**：直接使用 `Thread` 类创建线程。

```java
// 创建线程对象
Thread thread = new Thread("Thread-01") {
  @Override
  public void run() {
    // 要执行的任务
  }
};
// 启动线程
thread.start();
```

**方式二**：使用 `Runnable` 配合 `Thread` 。

把【线程】和【任务】（要执行的代码）分开：

- `Thread` 代表线程。
- `Runnable` 代表可运行的任务（线程要执行的代码）。

```java
// 创建任务对象
Runnable task = new Runnable() {
  @Override
  public void run() {
    // 要执行的任务
  }
};
// 创建线程对象
Thread thread = new Thread(task, "Thread-01"); // 参数 2 是自定义的线程名称
// 启动线程
thread.start();
```

Java 8 以后可以使用 Lambda 精简代码：

```java
// 创建任务对象
Runnable task = () -> log.debug("Hello");
// 创建线程对象
Thread thread = new Thread(task, "Thread-01");
// 启动线程
thread.start();
```

::: tip 自 Thread 与 Runnable 之间的关系：

- 用 `Runnable` 更容易与线程池等高级 API 配合。
- 用 `Runnable` 让任务类脱离了 `Thread` 继承体系，更灵活。

:::

**方式三**：使用 `FutureTask` 配合 `Thread`。

`FutureTask` 能够接收 `Callable` 类型的参数，用来处理有**返回结果**的情况。

```java
// 创建任务对象
FutureTask<Integer> task = new FutureTask<>(() -> {
  log.debug("Hello");
  return 100;
});
// 创建线程对象
Thread thread = new Thread(task, "Thread-01");
// 启动线程
thread.start();
// 主线程阻塞，同步等待 task 的执行完毕的结果
Integer result = task.get();
log.debug("结果是：{}", result); // 100
```

### 4.2 观察多个线程同时运行

我们可以开启多个线程来运行，然后观察👀运行的结果。

会发现，线程之间是交替运行的，谁先谁后，不由我们控制。

### 4.3 查看进程线程的方法

**Windows**

- 任务管理器可以查看进程和线程数，也可以用来杀死进程。
- 也可以在终端通过 `tasklist` 命令查看进程、`taskkill` 命令杀死进程。

**Linux**

- `ps -fe` 查看所有进程。
- `ps -fT -p <PID>` 查看某个进程（PID）的所有线程。
- `kill` 杀死进程。
- `top` 按大写 H 按键切换是否显示线程。
- `top -H -p <PID>` 查看某个进程（PID）的所有线程。

**Java**

- `jps` 命令查看所有 Java 进程。
- `jstack <PID>` 查看某个 Java 进程（PID）的所有线程状态。
- `jconsole` 来查看某个 Java 进程中线程的运行情况（图形界面）。

::: info jconsole 远程监控的配置：

1. 需要以如下方式运行你的 Java 类：

   ```shell
   java -Djava.rmi.server.hostname=`IP地址` -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=`连接的端口` -Dcom.sun.management.jmxremote.ssl=是否安全连接 -Dcom.sun.management.jmxremote.authenticate=是否认证 Java 类
   ```

2. 修改 `/etc/hosts` 文件将 `127.0.0.1` 映射至主机名。

3. 如果要认证访问，还需要做如下步骤：

   1. 复制 `jmxremote.password` 文件。
   2. 修改 `jmxremote.password` 和 `jmxremote.access` 文件的权限为 `600` 即文件所有者可读写。
   3. 连接时填入 controlRole（用户名）、R&D（密码）。

:::

### 4.4 原理之线程运行

#### 4.4.1 栈与栈帧

Java Virtual Machine Stacks （Java 虚拟机栈）。

我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。

- 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存。
- 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。

#### 4.4.2 线程上下文切换

Thread Context Switch（线程上下文切换）。

因为以下一些原因导致 CPU 不再执行当前的线程，转而执行另一个线程的代码：

- 线程的 CPU 时间片用完。
- 垃圾回收。
- 有更高优先级的线程需要运行。
- 线程自己调用了 `sleep`、`yield`、`wait`、`join`、`park`、`synchronized`、`lock` 等方法。

当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 JVM 指令的执行地址，是线程私有的：

- 状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等。
- Context Switch 频繁发生会影响性能。

### 4.5 Thread常见方法

| 方法名              | static | 功能说明                                                     | 注意事项                                                     |
| ------------------- | ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `start()`           | -      | 启动一个新线程，在新的线程运行 `run` 方法中的代码。          | `start` 方法只是让线程进入就绪，里面代码不一定立刻运行（CPU 的时间片还没分给它）。<br />每个线程对象的 `start` 方法只能调用一次，如果调用了多次会出现 `IllegalThreadStateException` 异常。 |
| `run()`             | -      | 新线程启动后会调用的方法。                                   | 如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的 run 方法，否则默认不执行任何操作。<br />但可以创建 Thread 的子类对象，来覆盖默认行为。 |
| `join()`            | -      | 等待线程运行结束。                                           | -                                                            |
| `join(long n) `     | -      | 等待线程运行结束,最多等待 n 毫秒。                           | -                                                            |
| `getId()`           | -      | 获取线程长整型的 ID。                                        | ID 唯一。                                                    |
| `getName()`         | -      | 获取线程名。                                                 | -                                                            |
| `setName(String) `  | -      | 修改线程名。                                                 | -                                                            |
| `getPriority()`     | -      | 获取线程优先级。                                             | -                                                            |
| `setPriority(int) ` | -      | 修改线程优先级。                                             | Java 中规定线程优先级是1~10 的整数，较大的优先级能提高该线程被 CPU 调度的机率。 |
| `getState()`        | -      | 获取线程状态。                                               | Java 中线程状态是用 6 个 enum 表示的， 分别为：<br/>NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED。 |
| `isInterrupted()`   | -      | 判断是否被打断。                                             | 不会清除打断标记。                                           |
| `isAlive()`         | -      | 线程是否存活（还没有运行完毕）。                             | -                                                            |
| `interrupt()`       | -      | 打断线程。                                                   | 如果被打断线程正在 `sleep`、`wait`、`join` 会导致被打断的线程抛出 `InterruptedException`，并清除打断标记。<br />如果打断的正在运行的线程，则会设置打断标记 。<br />`park` 的线程被打断，也会设置打断标记。 |
| `interrupted()`     | static | 判断当前线程是否被打断。                                     | 会清除打断标记。                                             |
| ` currentThread()`  | static | 获取当前正在执行的线程。                                     | -                                                            |
| `sleep(long n)`     | static | 让当前执行的线程休眠 n 毫秒，休眠时让出 CPU 的时间片给其它线程。 | -                                                            |
| `yield()`           | static | 提示线程调度器让出当前线程对 CPU 的使用主要是为了测试和调试。 | -                                                            |

::: warning  调用 start 方法与 run 方法的区别？

- 直接调用 `run` 是在主线程中执行了 `run`，并没有启动新的线程。
- 使用 `start` 是启动新的线程，通过新的线程间接执行 `run` 中的代码。

:::

::: warning  sleep 方法与 yield 方法？

`sleep`

1. 调用 `sleep` 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）。

2. 其它线程可以使用 `interrupt` 方法打断正在睡眠的线程，这时 `sleep` 方法会抛出 InterruptedException。
3. 睡眠结束后的线程未必会立刻得到执行。
4. 建议用 TimeUnit 的 `sleep` 代替 Thread 的 `sleep` 来获得更好的可读性。

`yield`

1. 调用 `yield` 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程。

2. 具体的实现依赖于操作系统的任务调度器。

:::

**线程优先级**：

- 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它。
- 如果 CPU 比较忙，那么优先级高的线程会获得更多的时间片，但 CPU 闲时，优先级几乎没作用。

### 4.6 `join` 方法详解

**未完待续...**
