---
title: 基础篇
icon: Code
# date: 2019-12-26
category: 面试题
tag: 面试题
timeline: true
star: true
---

此处是一些 Redis 的高频面试题（持续更新中...）。

<!-- more -->

## 基础篇

### <span style="color: #fb9b5f">Redis 中的数据结构有哪些？</span>

Redis 是一种基于内存的数据存储系统，支持多种灵活的数据结构。

以下是 Redis 中主要的数据结构：

1. String（字符串）：

   存储字符串值，可包含任意数据，例如文本、二进制数据。

   常用命令：SET、GET、INCR、APPEND 等。

2. Hash（哈希表）：

   存储字段和与字段相关联的值，类似于关联数组或对象。

   常用命令：HSET、HGET、HDEL、HGETALL 等。

3. List（列表）：

   存储有序的元素列表。

   可在列表的两端进行插入和删除操作。

   常用命令：LPUSH、RPUSH、LPOP、LRANGE 等。

4. Set（集合）：

   存储无序且唯一的元素。

   提供对集合进行交集、并集、差集等操作。

   常用命令：SADD、SREM、SMEMBERS、SINTER 等。

5. Sorted Set（有序集合）：

   类似于集合，但每个元素关联一个分数（score）。

   可以按照分数进行排序。

   常用命令：ZADD、ZREM、ZRANGE、ZSCORE 等。

6. Bitmap（位图）：

   存储二进制位的数据结构，支持位运算。

   常用命令：SETBIT、GETBIT、BITOP 等。

7. HyperLogLog：

   用于近似计数的数据结构，估算集合中不重复元素的个数。

   常用命令：PFADD、PFCOUNT、PFMERGE。

8. Geospatial（地理空间索引）：

   存储地理空间信息，如经度、纬度等。

   提供地理位置的计算和查询。

   常用命令：GEOADD、GEODIST、GEORADIUS、GEOHASH 等。

### <span style="color: #fb9b5f">Redis 的使用场景有哪些？</span>

Redis 一般用于**缓存数据**、**实现分布式锁**、**模拟消息队列**、**延迟队列**等场景。

### <span style="color: #fb9b5f">Redis 缓存数据可能会产生哪些问题？</span>

可能产生的问题：**缓存穿透**、**缓存雪崩**、**缓存击穿**、**双写一致性**、**持久化**、**数据过期**、淘汰策略等（以下面试题也是根据这些问题来展开的）。

### <span style="color: #fb9b5f">什么是缓存穿透？怎么解决？</span>

缓存穿透是指查询一个在数据库中**一定不存在的数据**，由于没有放置到缓存中，所以每次的请求都会到达数据库，在高并发场景下，这将有可能会导致数据库瞬时的压力过大而导致宕机。

解决方案一般有两种：

1. 给查询不到的数据**缓存空值**，并设置短暂的过期时间。
2. 使用 Redisson 实现的**布隆过滤器**来解决。

### <span style="color: #fb9b5f">可以介绍一下布隆过滤器吗？</span>

布隆过滤器一般是用于**检索一个元素是否在一个集合中**。

布隆过滤器的底层实现是先初始化一个大的数组，数组中的每个元素存放的是二进制的 0 或 1（初始都为 0）。

把一个 Key 经过 **3 次 hash** 运算，然后再 **% 数组的长度**，得到的结果作为数据在数组中的下标，再把对应下标中的 0 改为 1。

这样三个数组的位置就能标明一个 Key 是否存在（查找的过程也是一样的）。

当然，这也是有缺点的，布隆过滤器会存在一定的误判率，但是可以设置这个误判率，一般不超过 **5%**。

其实，这个误判率是一定会存在的，不然就需要增加数组的长度，5% 以内的误判率一般项目也可以接受，不至于在高并发场景下压垮数据库。

### <span style="color: #fb9b5f">什么是缓存击穿？怎么解决？</span>

在高并发的场景下，大量的并发请求同时访问了**同一个热点数据**，恰好该**热点数据已失效**，所以所有的请求都会到达数据库，可能会瞬间耗尽数据库的资源，最终导致数据库宕机。

解决方案一般有三种：

1. 使用**同步锁**（本地锁）来控制查询数据库的线程，只允许有一个线程去查询数据库，获得数据后存入到缓存中。

   优点：强一致性。

   缺点：

   - 如果是分布式场景下，还是会有多次查询数据库（因为锁对象是`this`而每个 JVM 都有一个`this`）。

   - 其次，因为使用的是同步锁，所以**对性能会影响**。

     ```java
     synchronized(this) {
       // 1.查询缓存中是否已存在数据
       // 2.查询数据库
       // 3.存入到缓存中
     }
     ```

2. 设置热点的 Key 为**逻辑过期配并配合互斥锁**来实现，大概思路如下：

   1. 缓存 Key 时，不给 Key 设置过期时间，但是多添加一个标识过期时间的字段；
   2. 当查询时，从 Redis 中获取数据后，先判断是否过期（未过期则正常返回数据）；
   3. 如果数据已过期，则首先获取互斥锁，然后在开启一个新的线程去同步数据，当前线程正常返回旧的数据，当新线程同步数据完成后，释放锁即可。
   4. 如果在重建缓存的过程中有其它线程来读取数据，发现数据已过期，则需要先获取锁，此时会获取锁失败，则返回旧的数据即可。
   5. 缓存重建完成后，锁也会被释放掉，此时的数据就是最新数据了。

   优点：高可用、性能佳。

   缺点：非强一致性。

3. **使用 Redisson 分布式锁来解决**。

### <span style="color: #fb9b5f">什么是缓存雪崩？怎么解决？</span>

缓存雪崩是指大量的 Key 使用了**相同的过期时间**，导致缓存在同一时间全部失效，在高并发场景下，所有的请求都会直接到达数据库，可能会导致数据库瞬间压力过大而宕机。

解决方案一般有两种：

1. 使用**同步锁或分布式锁**（对性能有影响）。
2. 给同一类 Key 的过期时间上增加一个随机值，比如 1～5 分钟的**随机时间**，把缓存过期时间重复率降低。

### <span style="color: #fb9b5f">如何保证 Redis 和 MySQL 的双写一致性？</span>

未完待续...
