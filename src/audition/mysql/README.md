---
title: MySQL
icon: MYSQL8
# date: 2019-12-26
category: 面试题
tag: 面试题
timeline: true
star: true
---

::: note

此处是一些 MySQL 高频面试题（持续更新中...）。

:::

<!-- more -->

## 面试题汇总

### 优化

::: info DQL 语句的执行顺序？

> ![DQL语句的执行顺序](./assets/DQL语句的执行顺序.png)

:::

::: info 在 MySQL 中如何定位慢查询？

> **原因**：
>
> - 聚合查询。
> - 多表查询。
> - 表数据量过大查询。
> - 深度分页查询。
>
> **表现**：页面加载过慢、接口压测响应时间过长（例如：超过 1s）。
>
> **定位**：
>
> - 开源工具：
>
>   - 调试工具：Arthas。
>
>   - 运维工具：Prometheus、Skywalking。
>
> - 配置 MySQL 自带慢查询日志（`/etc/my.cnf`）：
>
>   - 开启慢查询日志：`slow_query_log=1`（默认是 0 - 关闭状态）。
>   - 设置慢查询日志：`long_query_time=2`（SQL 执行超过 2 秒的则是慢查询 SQL - 默认 10 秒）。

:::

::: info 如何分析 SQL 执行慢的原因？

> SQL 执行计划：`explain`、`desc`（命令获取 MySQL 如何执行 SELECT 语句的信息）。
>
> ![SQL执行计划](./assets/SQL执行计划.png)
>
> type 字段表示这条 SQL 的连接的类型，性能由好到差为：
>
> - system：查询系统中的表。
> - const：根据主键查询。
> - eq_ref：主键索引查询或唯一索引查询。
> - ref：索引查询。
> - range：范围查询。
> - index：索引树扫描（==避免出现==）。
> - all：全盘扫描（==避免出现==）。
>
> ![额外的建议](./assets/额外的建议.png)

参考回答：

> 可以采用 MySQL 自带的分析工具 EXPLAIN 来查询 SELECT 语句的执行计划：
>
> - 通过 key 和 key_len 字段检查是否命中了索引（索引本身是否存在有失效的情况）。
> - 通过 type 字段查看 SQL 是否有进一步的优化空间，是否存在全索引扫描或全盘扫描。
> - 通过 extra 字段的额外建议判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复。

:::

::: info MYSQL 支持的存储引擎有哪些？它们有什么区别？

> 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。
>
> 存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。
>
> ![MySQL支持的存储引擎](./assets/MySQL支持的存储引擎.png)
>
> InnoDB 存储引擎：支持事务、外键、表级锁和行级锁（MySQL 5.5 之后的默认存储引擎）。
>
> MyISAM 是早期的存储引擎：它不支持事务、只有表级锁、也没有外键（用的不多）。
>
> Memory 主要把数据存储在内存中：支持表级锁、没有外键、没有事务（用的也不多）。

:::

::: info 什么是索引？有了解过索引吗？

> 索引（index）是帮助 MySQL 高效获取数据的一种**有序**的数据结构（不需要全标扫描）。

:::

::: info 索引的底层数据结构了解过嘛？

> MySQL 的 InnoDB 引擎采用的是 B+ 树的数据结构来存储索引的。
>
> 非叶子节点存储指针、叶子节点存储数据、叶子节点是一个双向循环链表。

:::

::: info B 树和 B+ 树有什么区别？

> Tips：B+Tree 是在 BTree 基础上的一种优化。
>
> B 树与 B+ 树的对比：
>
> 1. 磁盘读写代价 B+ 树更低。
> 2. 查询效率 B+ 树更加稳定。
> 3. B+ 树便于扫库和区间查询。

:::

::: info 什么是聚集索引和二级索引？

> 聚集索引：将数据存储与索引放到了一块，索引结构的叶子节点保存了整行的数据（有且只有一个）。
>
> 二级索引：将数据与索引分开存储，索引结构的叶子节点关联的是对应行的主键值（可以有多个）。
>
> 聚集索引选取规则：
>
> 1. 如果存在主键，则主键索引就是聚集索引。
> 2. 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。
> 3. 如果表没有主键，也没有合适的唯一（UNIQUE）索引，则 InnoDB 存储引擎会自动生成一个 `rowid` 作为隐藏的聚集索引。
>
> ![聚集索引和二级索引](./assets/聚集索引和二级索引.png)

:::

::: info 什么是回表查询？

> 通过二级索引找到对应的主键值，然后到聚集索引中查找整行数据，这个过程就是回表查询。
>
> ![回表查询](./assets/回表查询.png)

:::

::: info 什么是覆盖索引？

> 覆盖索引是指：查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到（不需要回表查询）。

:::

::: info MySQL 超大分页怎么处理？

> 可以通过覆盖索引加子查询的方式来解决。
>
> ```sql
> select * from tb_sku t,  (select id from tb_sku order by id limit 9000000, 10) a where t.id = a.id;
> ```
>
> 在数据量比较大时，如果进行 `limit` 分页查询，在查询时，越往后，分页查询效率越低。

:::

::: info 索引创建原则有哪些？

> 主键索引。
>
> 唯一索引。
>
> 复合索引（根据业务情况创建的索引）。
>
> **索引创建的规则如下**：
>
> 1. 针对于数据量较大，且查询比较频繁的表建立索引（一般单表超过10万数据（增加用户体验））- ==重点==。
> 2. 针对于常作为查询条件（`where`）、排序（`order by`）、分组（`group by`）操作的字段建立索引 - ==重点==。
> 3. 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
> 4. 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。
> 5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率 - ==重点==。
> 6. 如果索引列不能存储 `NULL` 值，请在创建表时使用 `NOT NULL` 约束它。当优化器知道每列是否包含 `NULL` 值时，它可以更好地确定哪个索引最有效地用于查询。
>
> 注意：要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率 - ==重点==。

:::

::: info 什么情况下索引会失效？

> 首先通过 `explain` 命令查看 SQL 语句执行计划。
>
> 1. 违反最左前缀法则（联合索引的情况下）：
>    - 指的是查询从索引的最左前列开始，并且不跳过索引中的列（索引生效）。
>    - 违反最左前缀法则（索引失效）。
>    - 如果符合最左前缀法则，但是出现跳跃某一列，则只有最左列的索引生效（最左列的部分生效）。
> 2. 如果在添加了索引的字段上进行了运算操作则索引会失效。
> 3. 字符串不加单引号会造成索引失效（只要发生了类型转换就会导致索引失效）。
> 4. 模糊查询的时候，如果 % 号在前面也会导致索引失效。

:::

::: info 谈一谈你对 SQL 的优化的经验。

> 表的设计优化（参考阿里开发手册《嵩山版》）：
>
> - 比如设置合适的数值（`tinyint`、`int`、`bigint`）- 要根据实际情况选择。
> - 比如设置合适的字符串类型（`char`、`varchar`）`char` 定长效率高、`varchar` 可变长度，效率稍低。
>
> 索引优化（参考索引创建原则和索引失效的情况）。
>
> SQL 语句优化：
>
> - SELECT 语句务必指明字段名称（避免直接使用 `select *`）。
> - SQL 语句要避免造成索引失效的写法。
> - 尽量用 `union all` 代替 `union`（`union` 会多一次过滤 - 效率低）。
> - 避免在 `where` 子句中对字段进行表达式操作。
> - Join 优化能用 `inner join` 就不用 `left join`、`right join`，如必须使用，一定要以小表为驱动，内连接会对两个表进行优化，优先把小表放到外边，把大表放到里边（`left join` 或 `right join` 不会重新调整顺序）。
>
> 集群优化（主从复制、读写分离）：
>
> - 如果数据库的使用场景读的操作比较多的时候，为了避免写的操作所造成的性能影响，可以采用读写分离的架构。
> - 读写分离解决的是，数据库的写入，影响了查询的效率。
>
> 分库分表。

:::

### 其它

::: info 。

:::

::: info 。

:::

::: info 。

:::

::: info 。

:::

::: info 。

:::

::: info 。

:::

::: info 。

:::

::: info 。

:::

::: info 。

:::

::: info 。

:::

::: info 。

:::
